---
title: 计算机网络
categories: 计算机知识
tags: [网络]
---

## Http/Https

### 简介

Http

- 超文本传输协议
- 本质是基于TCP协议通过80端口来传输数据
- 是一种允许浏览器向服务器获取资源的协议

Https

- 加密过程
  - HTTPS协议是由SSL/TLS+HTTP协议构建的
  - 采用了非对称加密+对称加密
  - 服务端将公钥A发送给客户端，客户端生成一个密钥X，用公钥A加密后发送给服务端，服务端用密钥A解锁后获得密钥X，这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可


### 结构

Http

- 起始行（Start Line）
  - 请求包：请求方式（Get/Post） + 请求路径（Url） + 版本（Http Version）
  - 响应包：版本（Http Version）+ 状态码 + 状态描述（Reason）
- 头部（Header）
  - Key-Value
- 空行（Crlf）
- 实体（Body）
  - 请求包：数据
  - 响应包：数据

### 请求流程

Http

- 构建请求包
  - 构建请求行，然后准备发起网络请求
- 查找缓存
  - 发起网络请求之前，先在浏览器缓存中查询是否有要请求的文件
    - 浏览器缓存是一种在保存在本地的资源副本
  - 有缓存则拦截该请求并返回资源副本
  - 没缓存则发起网络请求
- 准备IP地址和端口
  - DNS解析URL获取IP和端口信息
- 等待TCP队列
  - Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接
  - 如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成
  - 如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接
- 建立TCP连接
  - 三次握手
- 发送HTTP请求

### 处理流程

Http

1. 响应请求，返回相应包
2. 断开连接
   - 如果开启了Keep-Alive则不会断开连接（长连接）
   - 四次挥手断开连接
3. 重定向
   - 

## TCP/UDP

### 简介

TCP（Transmission Control Protocol，传输控制协议）

- 是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须要经过三次“对话”才能建立起来

UDP

- 是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 
- 一台服务机可同时向多个客户机传输相同的消息。

### 应用场景

- TCP：发信息，文件传输
- UDP：视频聊天，直播

### 区别

- TCP有连接，UDP无连接
- TCP一对一，UDP一对多
- TCP包头的最小长度为20字节, UDP包头为8字节。
- TCP面向连接，UDP面向报文
- TCP保证数据正确性，UDP可能丢包
- TCP保证数据顺序，UDP不保证

### 连接流程

TCP

- 三次握手
  1. 主机A通过向主机B发送一个含有同步序列号的标志位的数据段给主机B，向主机B 请求建立连接，通过这个数据段， 主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我
  2. 主机B 收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我
  3. 主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段："我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机A和主机B 就可以传输数据了
- TCP四次挥手
  1. 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求
  2. 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1
  3. 由B 端再提出反方向的关闭请求,将FIN置1
  4. 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束.
  
- time-wait的作用
  
  - time-wait开始的时间为tcp四次挥手中主动关闭连接方发送完最后一次挥手，也就是ACK=1的信号结束后，主动关闭连接方所处的状态。
  
    然后time-wait的的持续时间为2MSL. MSL是Maximum Segment Lifetime,译为“报文最大生存时间”，可为30s，1min或2min。2msl就是2倍的这个时间。一般根据实际的网络情况进行确定。
  
  - 为什么要持续这么长的时间呢
  
    - 为了保证客户端发送的最后一个ack报文段能够到达服务器。因为这最后一个ack确认包可能会丢失，然后服务器就会超时重传第三次挥手的fin信息报，然后客户端再重传一次第四次挥手的ack报文。如果没有这2msl，客户端发送完最后一个ack数据报后直接关闭连接，那么就接收不到服务器超时重传的fin信息报，那么服务器就不能按正常步骤进入close状态。那么就会耗费服务器的资源
  
    - 在第四次挥手后，经过2msl的时间足以让本次连接产生的所有报文段都从网络中消失，这样下一次新的连接中就肯定不会出现旧连接的报文段了。

### 名词解释

- ACK
  - 是TCP报头的控制位之一，对数据进行确认。确认由接收端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时,确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。
- SYN：
  - 同步序列号，TCP建立连接时将这个位 置1。
- FIN
  - 发送端完成发送任务位，当TCP完成数据传输需要断开时,，提出断开连接的一方将这位置1。

## 缓存机制

## 网络模型

### 7层模型

1. 应用层
   - http、dns、smtp
   - 传报文
2. 表示层
   - 压缩、加密、描述
3. 会话层
   - 数据交换、同步、建立检查、恢复方案
4. 传输层
   - tcp、udp
5. 网络层
   - ip协议
   - 传分组和包
6. 数据链路层
   - 传帧
     - head：报头（发送者、接收者、数据类型）
     - data：数据
7. 物理层
   - 传比特流

### 5层模型

- 应用层-传输层-网络层-数据链路层-物理层

## 重传机制

### 超时重传

- 超时重传时间是以RTO（数据发送时刻到接收到确认的时刻的差值）
  - 不稳定
  - 实际RTO应略大
- 如果重发的数据还需要重发，RTO翻倍

### 快速重传

- 接收方响应下一个接收的数据
- 连续响应了三次的话就是需要重传
- 但是服务端不知道重传一个还是之前所有的，都有可能

### SACK

- 选择性确认
- TCP头加一个map，接收方响应时需要传没接收到的数据map
- 服务端也是连续响应三次后重传

### D-SACK

- TCP头加一个map，接收方响应时需要传重复接收到的数据map
- 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
- 可以知道是不是「发送方」的数据包被网络延迟了;
- 可以知道网络中是不是把「发送方」的数据包给复制了;

## 流量控制

- 保证发送方和接收方的滑动窗口大小一致
- TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况
- 如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭
  - 如果接受方的窗口为0的ack丢失了，会导致死锁
    - 持续计时器，时间到再发一个询问（重复3次）
- 设置窗口阈值，避免糊涂窗口

## 滑动窗口

- 解决每次发送数据都需要接收ack后才能接着发的问题
  - 不用等待ack，使用缓存实现
- TCP 头里有一个字段叫 `Window`，也就是窗口大小。
  - 这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据
- 发送方内部通过三个指针表示，接收方内部通过两个指针表示
- 接收窗口的大小是**约等于**发送窗口的大小的

## 拥塞控制

### 为什么需要拥塞控制

- A给B发送数据，A迟迟没有收到B的ACK，那么A会觉得B没收到（丢失），A会重新发送
- 实际情况可能是网络拥塞了，A重复发送数据会导致网络更加拥塞，所以需要拥塞控制

### 拥塞控制策略		

- 刚开始以指数增长的速度发送数据包（1，2，4...），到达某个**阈值**后按线性速度发送数据包（1，2，3....），我们也把 A 一次性连续发送多少个数据包称之为**拥塞窗口**
- 指数增长阶段称为**慢启动**，线性增长阶段称为**拥塞避免**
- 当增长到某个值后肯定会出现**超时事件**，可以认为是出现网络拥塞了，暂且称这个值为**瓶颈值**，此时我们将阈值改为这个瓶颈值的一半，然后拥塞窗口从0开始增长
- 超时事件还有可能是数据包丢失了
  - 假设A给B发了m1,m2,m3,m4....
  - 当A连续收到三个确认m2的ACK时，且m3还没有发送超时事件，A就知道B的m3丢失了，A会快速重传m3，然后将阈值修改为瓶颈值的一半，然后拥塞窗口从阈值开始增长

## 状态码

- 301：301代表永久性重定向，旧地址被永久移除，客户端向新地址发送请求
- 302：302代表暂时性重定向，旧地址还在，客户端继续向旧地址发送请求
- 304(未修改)：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为 If-Modified-Since HTTP 标头)。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。
  - 如果服务器有变更，则从服务器重新下载，返回状态码200
- 500（服务器内部错误）：服务器遇到错误，无法完成请求
- 501（尚未实施）：服务器不具备完成请求的功能
- 502（错误网关）：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。
- 503（服务不可用）：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。
- 504（网关超时）：服务器作为网关或代理，未及时从上游服务器接收请求
- 505（HTTP 版本不受支持）： 服务器不支持请求中所使用的 HTTP 协议版本。

## 协议

### ARP

- IP --> MAC
- 在TCP/IP中属于网络层，在OSI中属于数据链路层

### SSl（Https加密协议）四次握手

## DNS寻址

### 什么是DNS

- DNS就是域名系统，是因特网中的一项核心服务，是用于实现域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址。通过主机名，得到该主机名对应的IP地址的过程叫做域名解析

### 解析过程

- 向浏览器输入一个域名，然后浏览器发起一个DNS解析请求，如果在本地缓存服务器中找不到，则向根服务器查询，根服务器会返回域名对应的顶级域服务器的位置信息
- 拿到顶级域服务器的位置信息后，就会去询问顶级域服务器，查找对应域名服务器的地址
- 拿到服务器地址后，查询域名，返回ip地址，缓存到本地服务器中
- 进入http的链接，顺利访问网站

## 路由转发

### 原理

- 二层转发：MAC地址表，广播可能有偶环路，STP防止，同一个VLAN实现
- 三层转发：路由表，静态路由配置错误有环路，TTL和路由协议解决

