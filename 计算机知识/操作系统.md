---
title: 操作系统
categories: 计算机知识
tags: [操作系统]
---

## 进程、线程、协程

### 定义

**进程**

- 是资源分配的最小单位
- 有自己独立的内存空间，不同进程之间内存不共享，通讯效率低，切换开销大
- 僵尸进程
  - 子进程调用exit结束自己的生命，其实没有真正的被销毁，只是释放了该进程所有的资源，之后剩下一个结构
  - 该结构保存了进程的部分信息（进程id，退出状态，运行时间等等）
  - 当父线程通过 wait()/waitpid() 方法才会真正销毁
  - 这样设计的目的是父线程可以知道子线程结束时的信息
  - 危害
    - 会一直存在，其进程号被占用，系统能使用的进程号是有限的，可能导致系统无法产生新的进程
  - 解决方法
    - 通过信号机制
    - 将子线程的父线程转变为init进程
    - 杀死导致僵尸线程的父线程
- 孤儿进程
  - 子进程还没运行结束，父进程已经结束了，那么该子进程称为孤儿进程
  - 后续将被init进程（进程id为1）收养，由init进程销毁

**线程**

- 是CPU调度的最小单位
- 可以有多线程，共享进程的内存空间，通讯效率高，切换开销小

**协程**

- 线程中的线程
- 协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行
- 协程中不能调用导致线程阻塞的操作，也就是说，协程需要和异步IO结合起来

### 状态

**进程**

- 

**线程**

- 新建(New)、就绪(Start)、运行(Running)、阻塞(SLeep / wait / IO)、死亡(Destroy)

**协程**

- 

### 通信方式

**进程**

- 消息队列、共享内存、信号量、Socket

**线程**

- volatile、wait/notify机制、ThreadLocal

**协程**

- 

### 同步方式

- 线程间
  - 互斥锁、条件变量、读写锁、信号量（PV操作）、信号处理

### 上下文切换

- 线程
  - 导致线程上下文切换的原因
    - 线程的cpu时间片用完
    - 垃圾回收
    - 有优先级更高的线程需要运行
    - 线程调用了sleep、yield、wait、join、park、synchronized、lock等
  - 当发生上下文切换时，由操作系统保存当前线程的状态，然后切换到另外一个线程运行，由程序计数器实现
    - 保存的状态有：栈帧的信息（局部变量，操作数栈，返回地址）
  - 频繁的上下文切换会影响性能
  - 线程切换要保存哪些上下文
    - 当前线程Id、线程状态、堆栈和寄存器状态等信息
    - 寄存器主要包括SP PC EAX等寄存器，其主要功能如下：
      - SP:堆栈指针，指向当前栈的栈顶地址
      - PC:程序计数器，存储下一条将要执行的指令
      - EAX:累加寄存器，用于加法乘法的缺省寄存器

### 优点

- 协程
  - 协程执行效率极高。协程不需要多线程的锁机制，可以不加锁的访问全局变量，所以上下文的切换非常快。
  - 执行协程只需要极少的栈内存（大概是4～5KB），而默认情况下，线程栈的大小为1MB。
  - 协程直接操作栈基本没有内核切换的开销，所以切换开销比线程少。

### 缺点

- 协程
  - 对计算密集型的任务也没有太大的好处

## 并发、并行

## 系统中断

### 软中断

### 硬中断

## 系统调度

### LRU

## 系统管理

进程管理、存储管理、设备管理、文件管理、程序接口、用户界面

## 寄存器

- 累加寄存器、基址寄存器、计数寄存器、数据寄存器、变址寄存器、指针寄存器
- 段寄存器
- 指令指针寄存器
- 标志寄存器

## 用户态和内核态

- 用户态
  - 只能执行受限的命令，不能直接调用系统资源，需通过内核接口来访问

- 内核态
  - 可以执行特权命令，调用一切系统资源
- 用户态 --> 内核态
  - CPU管理、内存管理、诊断和测试
  - 为了提高IO效率，用户态和内核态都加入了缓冲区

## 虚拟内存

## 局部性原理

## 浮点数

## 线程安全

### 简介

- 多个线程访问同一个共享变量就会出现线程安全问题
- private 和 final可以一定程度上提供线程安全
- 线程安全的方法组合起来就不能保证线程安全了

### 线程安全程度

- 不可变
  - final、枚举、Number部分子类（Long、Double、BigInteger、BigDecimal）、使用`Collections.unmodifiableXXX()` 包装的集合
  - 不可变类：DateFormatter、String
- 绝对线程安全
  - 调用者都不需要任何额外的同步措施
- 相对线程安全
  - 有一定的安全，但有意外的情况，例如顺序的连续调用
  - 通过一些同步方法来保证安全
- 线程兼容
  - 对象本身不安全，需要通过一些同步方法来保证安全
- 线程对立
  - 即使使用了同步方法也无法保证线程安全

### 临界区

- 多线程读写同一个共享资源，这个共享资源就称为临界区

### 竟态条件

- 多个线程同时在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竟态条件

## 锁机制

### 死锁

- 死锁就是多线程之间争夺系统共享资源，然后出现相互等待的情况
  - 互斥：已获取的资源不允许其他进程访问，直到资源释放才能访问
  - 请求和保持：已有资源，然后要访问其他进程占有的资源，但是本身的资源不释放
  - 不可抢占：获取的资源未使用完之前都不可被其他线程访问
  - 循环等待：存在进程之间资源的循环等待
- 死锁的解决方法
  - 所有资源一次申请，或者逐步申请，用完释放
  - 让使用同一把锁的多个线程的加锁顺序一致
  - 设置获取锁的超时时间，没得到资源则释放已有资源
  - 死锁检测，查代码防止死锁
    - console工具
    - jps定位进程，jstack导出dump日志，定位死锁代码
- 一个线程要获取多把锁容易出现死锁
- 出现死锁怎么办
  - 重启或者kill

## 伪共享

- CPU在向内存发起IO操作的时候，一次性会读取64个字节的数据作为一个缓存行， 缓存到CPU的高速缓存里面
- 以缓存行的设计对于CPU来说，可以有效的减少和内存的交互次数，从而避免了CPU 的IO等待，以提升CPU的利用率
- 因为这种缓存行的设计，导致如果多个线程修改同一个缓存行里面的多个独立变量的时候，基于缓存一致性协议，就会无意中影响了彼此的性能，这就是伪共享
  - 即当一个线程修改了缓存行中的数据时，其他线程需要重新读取缓存行中的数据
- 解决方式
  1. 对齐填充，因为一个缓存行是64字节，当读取的目标数据小于64字节时，可以填充一些无意义的数据使其字节接近或达到64字节，这样就可以使一个缓存行只被一个线程所持有