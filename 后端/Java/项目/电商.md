---
title: 电商
categories: 模块
tags: [模块]
---

## 商品管理

### SKU和SPU

- SKU是 库存量单位
  - 商品信息参数的聚合，如商品的规格参数
- SPU是 标准化产品单元
  - 商品信息的聚合，如一个概览信息，也成为销售属性
- SPU像是类，SKU像是对象

### 分类-品牌-属性

- 各表之间独立存储，通过关联表关联
- 提供添加关联的功能
  - 属性分组和规格参数关联

- 属性
  - 属性分组
    - 基本信息
    - 主体信息

  - 规格参数（基本参数）
    - 详细的信息

  - 销售属性

## 仓库管理

### 库存维护

### 采购单维护

![image-20230325113549822](../../pic/image-20230325113549822.png)

#### 合并采购单

- 将采购需求合并为一个采购单，并分配给对应的人员
- 需要为采购需求设置状态
  - 新建、已分配、已领取、已完成、有异常

#### 领取采购单

- 领取了采购单则标记为已领取

#### 完成采购

- 需要判断全部采购完成还是部分采购完成

## 订单超时处理

### JDK自带的延时队列

#### 实现

1. 把订单插入DelayQueue中，以超时时间作为排序条件，将订单按照超时时间从小到大排序。
2. 起一个线程不停轮询队列的头部，如果订单的超时时间到了，就出队进行超时处理，并更新订单状态到数据库中。
3. 为了防止机器重启导致内存中的DelayQueue数据丢失，每次机器启动的时候，需要从数据库中初始化未结束的订单，加入到DelayQueue中。

##### 优点

- 简单，不需要借助其他第三方组件，成本低。

##### 缺点

- 所有超时处理订单都要加入到DelayQueue中，占用内存大。
- 没法做到分布式处理，只能在集群中选一台leader专门处理，效率低。
- 不适合订单量比较大的场景。

### RabbitMQ的延时消息

#### 实现一

- 使用官方提供的延时消息插件 RabbitMQ Delayed Message Plugin

##### 优点

- 方便，易用

##### 缺点

- 不是高可用的，节点挂起会导致消息丢失

#### 实现二

- 消息的TTL+死信Exchange
  - TTL：
    - 即消息的存活时间。RabbitMQ可以对队列和消息分别设置TTL，如果对队列设置，则队列中所有的消息都具有相同的过期时间。
    - 超过了这个时间，我们认为这个消息就死了，称之为死信。
  - 死信Exchange（DLX）：一个消息在满足以下条件会进入死信交换机
    - 一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不会被再次放在队列里，被其他消费者使用。
    - TTL到期的消息。
    - 队列满了被丢弃的消息。

##### 优点

- 可以支持海量延时消息，支持分布式处理。

##### 缺点

- 不灵活，只能支持固定延时等级。
- 使用复杂，要配置一堆延时队列。

### RocketMQ的定时消息

#### 实现

- 只要在发送消息时设置延时时间即可

##### 优点

- 精度高，支持任意时刻。
- 使用门槛低，和使用普通消息一样

##### 缺点

- 使用限制：定时时长最大值24小时。
- 成本高：每个订单需要新增一个定时消息，且不会马上消费，给MQ带来很大的存储成本。
- 同一个时刻大量消息会导致消息延迟：定时消息的实现逻辑需要先经过定时存储等待触发，定时时间到达后才会被投递给消费者。因此，如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大，导致消息分发延迟，影响定时精度。

### Redis过期监听

#### 实现

- redis配置文件开启"notify-keyspace-events Ex"
- 监听key的过期回调
- 每当我们对一个key设置了过期时间，Redis就会把该key带上过期时间，存到过期字典中，在redisDb中通过expires字段维护：
- 有定期删除和惰性删除两种

##### 优点

- 

##### 缺点

- 不可靠，不准确

### 定时任务分布式批处理

#### 实现

- 使用分布式任务调度系统SchedulerX，不但兼容主流开源任务调度系统和Spring @Scheduled注解，还自研了轻量级MapReduce模型[4]，针对任意异构数据源，简单几行代码就可以实现海量数据秒级别跑批
  - 通过实现map函数，通过代码自行构造分片，SchedulerX会将分片平均分给超时中心的不同节点分布式执行
  - 通过实现reduce函数，可以做聚合，可以判断这次跑批有哪些分片跑失败了，从而通知下游处理

##### 优点

- 稳定性强，需要保证业务幂等
- 效率高，使用定时任务跑批方案，一次捞出一批订单，处理完了，可以批量更新订单状态，减少数据库的tps。在海量订单处理场景下，批量处理效率最高
- 可运维,基于数据库存储，可以很方便的对订单进行修改、暂停、取消等操作，所见即所得。如果业务跑失败了，还可以直接通过sql修改数据库来进行批量运维
- **免运维、成本低：**不需要自建任务调度系统，由云上托管。
- **可观测：**提供任务执行的历史记录、查看堆栈、日志服务、链路追踪等能力。
- **高可用：**支持同城双活容灾，支持多种渠道的监控报警。
- **混部：**可以托管阿里云的机器，也可以托管非阿里云的机器。

##### 缺点

- 没法做到精度很高。定时任务的延迟时间，由定时任务的调度周期决定。如果把频率设置很小，就会导致数据库的qps比较高，容易造成数据库压力过大，从而影响线上的正常业务
- 所以一般需要抽离出超时中心和超时库来单独做订单的超时调度

## 抢红包

### 问题分析

- 发红包
  - 不需要加锁，发红包没有竞争
  - 拆分红包
    - 确保原子性并且不加锁
    - 拆分红包使用二倍均值算法：抢到的金额 = 随机（0，剩余红包金额 / 剩余红包数 * 2）
  - 存红包
    - 红包存redis中的list，lpush存，lpop取，设置过期时间，返回一个红包的key
    - 存redis后会有一个唯一key
- 抢红包
  - 根据redis中存的红包key
  - 用另一个hash表记录红包的消费信息
  - 使用用户的token判断是否重复抢，没在hash中的才能抢
- 统计红包记录
  - 根据hash表中记录的
- 红包回退
- 配置红包雨数量、金额、时间等

### 架构

- redis集群（写 8万/s）

## 秒杀

### 总体思路

- 秒杀最主要的是查看商品详情页和下单两个模块
- 查看商品详情页
  - 前端从CDN上取得页面数据，后端将页面静态化后存到cdn上
  - 添加nginx做负载均衡，然后用redis缓存，nginx访问redis
    - redis中没有数据再去查JVM缓存
    - JVM缓存中没有再去查数据库
- 下单
  - 

### 全局唯一ID

- 需要满足唯一性，安全性，高可用，高性能
- 使用Redis中的incrby实现
  - 符号位（1）+ 时间戳（31）+ 序列号（32）
    - 时间戳 = 当前时间 - 自定义的一个过去的时间常量
    - 序列号 = “一些前缀” + 当前时间 + 1
    - 返回     时间戳 << 32 | 序列号
- 使用雪花算法
  - 1bit + 时间戳（41）+ 机器id（10）+ 序列号（12）
  - 同一毫秒生成的id不超过4095，超过4095则到下一毫秒生成
  - 由于每一台机器的工作机器id不同，所以分布式环境下也不会冲突

### 防止库存超卖

- CAS

- Synchronize

- 分布式锁

### 一人一单

- 需要在扣减库存前进行判断，并且把判断过程和扣减库存用synchronize锁住
- 以userId作为锁
- 在分布式系统下无法保证，需要使用分布式锁

### 异步秒杀

- 由于当前大多数业务都是在tomcat中串行执行的，效率低
- 把秒杀券信息也保存到redis中
- 所以我们可以把判断库存、扣减库存和一人一单校验放在redis中进行
  - 使用lua脚本确保原子性
- 用户秒杀成功后将优惠券id和用户id存入**阻塞队列**中，将订单id返回给用户
- 开启线程任务不断读取**阻塞队列**中的订单异步下单

### 消息队列

- 使用Stream的Group（消费组）实现消息队列

  - 消息分流
    - 队列中的消息会分流给组内不同的消费者，从而加快消息处理速度
  - 消息标示
    - 会维护一个标识记录最后一个被处理的消息，即使宕机重启，还会从标识之后读取消息，确保每一个消息都被消费
  - 消息确认
    - 消费者获得消息后，消息会处于pending状态，并存入一个pending-list，当处理完消息后需要通过XACK来确认消息，标记消息已处理，才会从pending-list移除
  - 可以阻塞读取
  - 消息可回溯，即持久化存储

  #### 步骤

  - 创建一个StreamGroup类型的消息队列，名为stream.orders
    - `XGROUP CREATE stream.orders g1 0 MKSTREAM`
  - 使用lua脚本向消息队列中添加消息
  - 开启一个线程从消息队列中取出消息
    - 判断信息是否为空
      - 空继续下一轮循环
      - 非空解析信息然后创建订单
  - 确认消息队列中的消息
  - 如果这个过程出现异常需要处理pending-list
