---
title: 系统设计
categories: 开发
tags: [开发]
---

# 简介

### CRM（客户关系管理系统）

- 应用
  - OA系统、HR系统

### SRM（供应商关系管理系统）

- 应用
  - 进销存系统

### SCM（供应链管理系统）

- 应用
  - 数据中台

### SaaS（软件即服务）

- 开箱即用
- 应用
  - 第三方系统、OA系统、HR系统、网盘

### PaaS（平台即服务）

- 应用
  - 开源系统、第三方Api/服务

### IaaS（基础架构即服务）

- 应用
  - 虚拟机、云存储、云服务器

## 项目开发流程

1. 设计产品原型
2. 需求分析
3. 模块设计
4. 接口文档
5. 前后端分离开发
6. 测试
7. 部署上线

## 一致性

- 多级缓存一致性
- 事务一致性

## 稳定性

- 有异常但不影响使用，但是要刨根问底的解决

## 平滑性

- 项目部署

## 产品技术思维

- 即很多技术问题可以通过业务手段来规避
  - 12315为例
    - 存储的性能的挑战
    - 通过分时段售票，候补票机制，验证码等等规避

## 反常规设计

- 12306抢票设计
  - 通过分时段抢票、候补票等机制规避了超高并发的设计困难

# 设计模式

## 类关系设计

- 关联关系
  - 单 / 双/ 自 关联
- 聚合关系
  - 整体和部分的关联
  - 部分可以脱离整体对象并独立存在
- 组合关系
  - 整体和部分的关联，更强烈的聚合关系
  - 部分不能脱离整体对象并独立存在
- 继承 / 泛化关系
- 实现关系
- 依赖关系
  - 是一种使用关系，耦合度最低
  - 是一种临时性的关联
  - 例如调用某个类的局部变量/静态方法，作为方法的入参

## 设计原则

- 接口单一职责
  - 一个接口只处理一种类型的任务
- 接口隔离原则
  - 接口实现类不应该被迫依赖其不使用的方法
  - 一个类对另一个类的依赖应该建立在实现最少的接口
- 依赖倒装原则
  - 如controller不直接使用接口实现类，而是使用的接口提供的方法
  - 即高层模块不依赖低层模块，两者都应该依赖其抽象接口
  - 对抽象进行编程，而不是对实现进行编程
- 合成复用原则
  - 尽量使用聚合、关联、组合等类的关系，其次在考虑继承	
- 里氏替换原则
  - 在使用父类的地方，其子类可以完全替换其父类
  - 子类应该扩展父类的方法，但不要重写父类的方法
- 迪米特法则
  - 两个实体最好不要直接通信，最好通过第三方通信
- 开闭原则
  - 对修改封闭，对扩展开放
  - 在程序需要扩展时不应该去修改源代码，而是实现一种热插拔的形式
  - 程序设计扩展性要好、易维护、易升级
  - 即尽量使用接口和抽象类

## 创建型设计模式

### 单例模式

```java
//饿汉构造
public class Hungry {
    public static final Hungry HUNGRY = new Hungry();
    private Hungry(){}
}
//枚举
public enum  Hungry {
    INSTANCE;
}
//饿汉代码块
public class Hungry {
    public static final Hungry HUNGRY;
    static {
        /*一般在这个静态代码块中加载配置*/
        HUNGRY = new Hungry();
    }
    private Hungry(){}
}

//懒汉构造
public class Lazy {
    private static Lazy lazy = null;
    private Lazy(){}
    //锁的粒度比较粗
    public static synchronized Lazy getInstance(){
        if (lazy == null)
            return lazy = new Lazy();
        return lazy;
    }
}
//双重检查锁
public final class Lazy implements Serializable{
    //防止指令重排和使用到半初始化状态的对象
    volatile private static final Lazy INSTANCE = null;
    private Lazy(){
        //防止反射破坏单例
        synchronized{
            if(INSTANCE != null) {
                throw new RuntimeException("不能创建多个单例对象");
            }
        }
    }
    public static Lazy getInstance(){
        //提高效率，当有实例了不用再去争抢锁
        if(INSTANCE == null) {
            synchronized (Lazy.class) {
                //防止阻塞队列的线程重新创建对象
                if (INSTANCE == null)
                    return INSTANCE = new Lazy();
            }
        }
        return INSTANCE;
    }
    //防止反序列化时返回新的对象
    public Object readResovle(){
        return INSTANCE;
    }
}
//内部类
public final class Lazy {
    private Lazy(){}
    private static class inner{
        private static final Lazy LAZY = new Lazy();
    }
    public static Lazy getInstance(){
        return inner.LAZY;
    }
}
```

### 工厂模式

### 建造者模式

- 用于构造复杂对象
- 包含四个角色
  - 抽象建造者类（Builder）：接口
  - 具体建造者类（ConcreteBuilder）：实现Builder接口
  - 产品类（Product）：要构造的复杂对象
  - 指挥者类（Director）：调用ConcreteBuilder来创建Product复杂对象

### 原型模式

- 需要频繁创建对象的场景，并且这些对象都属于同一种类型
- 通过clone方式实现对象创建
- 一般结合工厂模式实现
- 使用场景
  - 账单推送

## 结构型设计模式

### 代理模式

### 组合模式

- 部分整体
- 定义个各层次对象的共有方法和属性，预先定义一些默认的行为
- 定义非叶子节点的行为，存储子节点，组合非叶子节点和叶子节点形成树
- 定义叶子节点下无分支
- 有透明组合模式和安全组合模式
  - 透明组合模式是标准模式
    - 不安全，叶子节点不应该具有添加、删除等功能
  - 安全组合模式
    - 安全，不同的节点提供其对应的方法，实现复杂

### 适配器模式

- 扩展新的访问方式
- 使用场景
  - 适用与调用端较多、需求变化频繁的场景

## 行为型设计模式

### 观察者模式

### 解释器模式

- 有性能问题和类膨胀问题
  - 采用的是递归的调用方式，复杂度比较高，而且不容易debug，代码维护比较麻烦
  - 每个解释器的语法的结束都会产生一个非终结符表达式，导致类文件过多膨胀，不好维护

### 模板方法模式

- 提高现有代码的扩展能力
- 代码中提供增加扩展的方法，可以用一个集合存放可能扩展的功能接口，然后再代码中遍历调用
- 大致的实现确定，少部分不确定的，就可以将这部分设计为模板
- 这部分将推迟实现，提高代码复用性，实现反向控制
- 使用场景
  - 处理用户行为日志

## 代码设计

### 简单工厂模式

- 将调用方和类解耦，将具体业务放在工厂类中实现
  - 封装了创建对象的过程，避免了修改调用方代码，更容易扩展
  - 虽然解除了调用方和类的耦合，但是产生了新的耦合，即工厂类和类的耦合，修改业务时依然需要修改工厂类代码，违背了开闭原则

- 可以把工厂类中的业务方法定义为静态的，方便调用

### 两阶段终止模式

- 一个线程t1 优雅的停止另一个线程t2，给t2一个料理后事的机会
- 如果直接终止t2会导致t2锁住的资源无法释放，导致死锁

# 分布式设计

## 分布式寻址

### 哈希取余分区

#### 简介

- 根据集群数量哈希取余，均匀的分配到每一台机器上

#### 优缺点

- 优点是简单
- 缺点是不利于扩容，还有就是如果节点宕机需要重新取余，不稳定

### 一致性哈希算法分区

#### 简介

- 对2^32^ 取余

#### 步骤

- 算法构建一致性哈希环
  - 将 0 ~ 2^32^ 的线性空间拼接成一个环
- 服务器IP节点映射到这个哈希环上
- key落到服务器的落键规则
  - 请求同样对2^32^ 取余，然后落在环上顺时针走，遇到的第一个服务器就处理这个请求

#### 优缺点

- 优点
  - 容错性高、扩展性强
- 缺点
  - 节点太少回导致数据倾斜的问题
    - 通过虚拟节点解决

### 哈希槽分区

#### 简介

- 用一个 2^14^ 大的数组，作为哈希槽
- 最多只有16384个槽
- 因为redis的节点不会超过1000个，够用了
- 相当于在请求和redis之间添加了一个反向代理（槽），由它来选择存储的redis节点

## 幂等性

### 接口幂等

- 同一个接口请求多次结果相同

#### 方案

1. 把传入的数据md5转换后存入redis，使用setnx存入
2. 数据库唯一约束
3. 前端发请求携带一个额外的token，两次token一致则不执行
4. 加乐观锁（csa）
5. 状态机
6. 插入前先查找
7. 加悲观锁

## 分布式缓存

1. Redis哨兵集群、分片集群

## 分布式锁

### 具体实现

1. MySQL实现
   - 创建一张锁表，加锁时在锁表中添加一条记录，释放锁时删除记录
   - 如果有并发请求同时提交到数据库，数据库会保证只有一个请求能够得到锁
   - 属于数据库 IO 操作，效率不高，而且频繁操作会增大数据库的开销，因此这种方式在高并发、高性能的场景中用的不多
2. ZooKeeper实现
   - 是一个比较重的分布式组件
3. Redis实现
   - setNx，需要加入过期时间
   - Redission

## 分布式事务

### XA协议

- 因为多个事务在多个不同的节点上执行，其中一个节点失败或者延迟，往往会导致整个系统的一致性受到破坏
- 角色
  - AP（Application）：应用系统（服务）
  - TM（Transaction Manager）：事务管理器（全局事务管理）
  - RM（Resource Manager）：资源管理器（数据库）

### 具体实现

1. 两阶段提交（2PC）
   - 可以保证事务的原子性和一致性，但是需要额外的开销和时间，不适合高并发和高吞吐的系统
   - 整个过程中事务管理器（TM）很关键，如果其宕机会导致资源管理器（RM）不可用
   - 事务处理过程中资源管理器（RM）处于阻塞状态，事务提交后才释放资源
   - 由于网络问题可能出现数据不一致的问题（部分节点没有接收到Commit操作）
2. 三阶段提交（3PC）
   - 为解决两阶段提交协议的单点故障和同步阻塞问题
   - 步骤
     - CanCommit：准备阶段。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应
     - PreCommit：预提交阶段。协调者根据参与者在**准备阶段**的响应判断是否执行事务还是中断事务，参与者执行完操作之后返回ACK响应，同时开始等待最终指令
     - DoCommit：提交阶段。协调者根据参与者在**准备阶段**的响应判断是否执行事务还是中断事务
3. 补偿机制（TCC）
   - 在业务层实现的分布式事务，保证最终一致性
     - 配合状态机实现
     - Try：资源检测和预留
     - Confirm：完成资源操作业务，Try成功，Confirm一定要能成功
     - Cancel：预留资源释放，可以看作是try的反向操作，即回滚
   - 规避了两阶段提交数据库性能低下的问题
   - 由于在业务层实现，所以开发成本高，对业务侵入较大和耦合度高
4. 消息队列
   - 使用MQ的事务消息机制
   - 将事务的各个阶段转化为消息的处理，以此来确保事务的顺序性和一致性
   - 存在延迟和数据重复的问题
5. 本地消息表
   - 将分布式事务拆分成本地事务进行处理，属于最终一致性
   - 步骤
     - 在数据库中新增一张消息表，将事务操作记录到消息表中（两个操作在一个事务中）
     - 通过轮询的方式将消息表中新增的消息推送到mq，数据库再去mq中消费信息（保证幂等）
     - 数据库处理完成后

### 框架

1. Seata
   - 使用的是两阶段提交

## 分布式限流

### 限流算法

1. 计数器
   - 设置单位时间内能够处理的最大请求数
   - 存在浪费性能的问题
     - 请求可能在单位时间内早就处理完成了，剩余的时间没处理请求，资源浪费
     - 该问题也称为 突刺现象 
2. 漏桶算法
   - 漏桶流算法
   - 令牌桶算法

## 分库分表

