---
title: JavaSE
categories: Java基础
tags: [基础]
---

## 简介

### 面向对象语言

- 封装
  - 将数据和操作封装为一个不可分割的整体
  - 隐藏内部的实现细节，对外暴露安全的访问方法
  - 提高了安全性和复用性，减少耦合
- 继承
  - 从已有对象中派生出一个类，这个类具有父类的属性和方法
  - private方法不会被继承
  - 提高了复用性，增加了耦合性

- 多态
  - 条件：继承，子类对象指针指向父类、满足里氏替换原则
  - 优缺点
    - 优点：提高代码的可扩展性
    - 缺点：无法使用子类特有方法

  - 分为编译时多态和运行时多态
    - 编译时多态：方法的重载
    - 运行时多态：程序中定义的对象引用所指向的具体类型在运行期间才确定

### rt.jar、dt.jar、tools.jar

- rt.jar
  - 代表runtime JAR，包含Core Java API的所有类，包含所有核心Java 运行环境的已编译calss文件
  - 位于JRE的lib目录下，包含了JVM信任的class文件，JVM加载时不会对其他class文件进行严格的安全检查
  - 是一个类似zip的压缩文件，精确称为 Java archive（Jar），存储了Java class文件和程序所需的全部资源。它还可以包含==mainfest==文件，还可以包含==Main-Class条目==，变成可执行JAR
- dt.jar
  - 是系统用来编译一个类的时候用到的，即执行javac的时候用到。
- tools.jar
  - dt.jar是关于运行环境的类库，主要是swing包。

### Fail-Fast和Fail-Safe

- Fail-Fast：一旦发现遍历时有修改，则立刻抛异常，例如ArrayList，vector
  - ArrayList内部的modCount记录了修改次数，当遍历时会获取modCount
  - 遍历过程会比较当前modCount和获取时的值，不一致抛异常
- Fail-Safe：遍历的同时有修改，会有相应的策略，例如CopyOnWriteArrayList

## 概念

### 关键字

#### transient

- 修饰的字段不参与序列化，只能修饰变量
- 当这个变量可以通过其他变量来获得时就可以不参加序列化，即添加transient修饰
  - 例如：三角形的长，宽，面积，则面积可以不参与序列化
  - Logger对象也不需要

#### static

- 修饰的静态变量是不参与序列化的

#### volatile

- 修饰的变量不会被cpu所缓存

#### final

#### try / catch / finally

#### throw / throws

### 数据类型

#### 基本数据类型

| 数据类型 |      | 长度 / 字节数 |
| -------- | ---- | ------------- |
| byte     |      |               |
| int      |      | 4字节         |
| long     |      | 8字节         |
| float    |      | 4字节         |
| double   |      | 8字节         |
| decimal  |      |               |

#### 引用数据类型

- String
  - 使用双引号创建字符串和使用new创建字符串是不一样的

### 抽象类

- 自底向上的抽象，将共性方法抽取出来作为父类
- 有抽象方法的类是抽象类，但抽象类也可以有其他普通方法

### 接口

- 自顶向下，对行为的规范，体现了模板设计思想
- 1.8之前只能有抽象方法，1.8之后可以有默认方法、静态方法
  - 静态方法只能被接口调用
  - 默认方法，作用是实现接口演化，为老接口扩展新功能，并且其实现类不用重新实现该新方法从，但是所有实现类都会默认携带这个新方法，有一点违背接口隔离原则
  
- 只能有static final 修饰的成员变量

### 方法

#### hashcode() / equals()

- 在集合中存储自定义对象类型最好重写这两个方法
- 重写hashcode()是为了对象的key在整个hashmap中有更好的分布，提高查询性能
- 重写equals()是为了防止两个对象的hash值一样，通过比较值来区分

### 反射

- 可以在运行期间获取类的各种信息，常用于一些动态修改属性值的操作
- 如果对象为private等类型，可使用setAccessible(true)暴力获取

### 注解

#### 元注解

- @Target：描述注解能够作用的位置
- @Retention：描述注解被保留的阶段
- @Documented：描述注解是否被抽取到api文档
- @Inherited：描述注解是否被子类继承

#### 预定义注解

   * @Override：检测方法是否覆盖重写父类方法

   * @Deprecated：标注的内容表示已过时

   * @suppressWarnings：压制警告

#### 自定义注解

1. 本质上就是一个接口，可定义方法，需要有返回值
2. 创建一个。。。。实现功能

### 异常

![img](https://pdai.tech/images/java/java-basic-exception-1.png)

#### 分类

- Throwable
  - 包含了线程创建时线程执行堆栈的快照，提供了printStackTrace()等接口用于获取堆栈信息
- Error
  - 是程序无法处理的异常，例如虚拟机运行错误、堆栈溢出等等
  - 无法检测的异常
- Exception
  - 程序可以捕获且处理的异常
  - 分为运行时异常和编译时异常
    - 运行时异常：RuntimeException类及其子类
    - 编译时异常：需要处理才能编译通过的异常

#### 自定义异常

- 需要继承RuntimeException
- 定义错误码和错误消息，还有各种参数的构造函数，包含异常信息，在抛异常的时候传入

#### 异常捕获

- 使用try/catch手动捕获
  - 自己对异常进行处理
- 直接抛出方法外，让调用方对异常进行处理
- 使用异常拦截器拦截统一处理（推荐）

#### 底层

- 底层是通过异常表Exception Table
- 异常表中包含了一个或多个异常处理者(Exception Handler)的信息，这些信息包含如下
  - **from** 可能发生异常的起始点
  - **to** 可能发生异常的结束点
  - **target** 上述from和to之前发生异常后的异常处理者的位置
  - **type** 异常处理者处理的异常的类信息

### 泛型

- 可以在定义类或方法时不传入特定类型的对象或参数，更具通用性
- 可以控制类的上限和下限
- 静态方法和异常中不能使用类的泛型
- 如果没有指定泛型的类型，默认是Object

### 枚举

- 常用于集中管理相同类型的信息，避免硬编码于代码中

### 代理

### 序列化

- 就是将对象转换成字节序列，实现持久化和网络传输
- 方式
  - 实现Serializable接口
  - 实现Externalizable接口
    - 实现writeExternal()
    - 实现readExternal()
- transient可以防止属性序列化，因为序列化可能会破坏单例

## 集合

### List

#### ArrayList

- 有序，可重复，可null
- 底层是数组，增加、删除、扩容都是通过数组的复制
- 可以利用CPU缓存，==局部性原理==

#### LinkedList

- 占用内存多，可null
- 底层是一个双向链表
- 内部维护了First和last节点，所以对首尾的操作方便
- ==在遍历时会判断从前往后较快还是从后往前较快==

#### Vector

- 线程安全，速度慢，早期使用Elements遍历
  - Enumeration接口是迭代器前身

#### CopyOnWriteArrayList

- 底层实现采用写入时拷贝的思想，增删改会将数组拷贝一份，在拷贝的数据上更改，不影响其他线程的并发读，读写分离

### Deque

#### ArrayDeque

- 用作栈或队列
- 初始容量8，扩容两倍
- 底层是循环数组，维护了 head 和 tail，非线程安全，不可存null值

### Queue

#### PriorityQueue

- 优先级队列，不可null
- 能保证每次取出的元素都是队列中权值最小的
- 底层是小顶堆结构，用数组实现，是按层序遍历树排列
- 初始容量11，扩容通过数组的复制，最大长度是数组的最大值

#### BlockingQueue

- 获取队列元素时队列为空会阻塞等待至队列不为空时，存储元素时队列满了会阻塞至队列直到队列可用
- 可以很好的实现生产者消费者模型
- ArrayBlockingQueue
  - 有界阻塞队列，
  - 基于循环数组实现，需要提前初始化数组
  - 内部维护一把锁，ReentrantLock 和 Condition


- LinkedBlockingQueue
  - 无界阻塞队列
  - 内部使用了两把锁，分别锁头尾指针，允许两个线程同时执行
  - 保证了头尾节点的线程安全

#### LinkedQueue

ConcurrentLinkedQueue

- 内部维护两把CAS锁，允许两个线程同时执行

### Set

#### HashSet

- 非线程安全，不重复，无序，底层hash表
- 对HashMap进行了一个封装，内部都是调用的hashmap的方法，适配器模式
  - key存值，value存的是常量

#### LinkedHashSet

- 有序，不重复
- 底层哈希表

### Map

#### HashMap

- 无序，可null，数组是懒惰创建的
- 底层
  - 1.7：数组+链表
  - 1.8：数组+链表 or 红黑树
- 默认16，扩容2倍，数组复制
  - 1.7：
    - 大于等于阈值且插入时的位置不为空时扩容
  - 1.8：
    - 大于阈值就扩容，不改变原链表或红黑树的顺序
- put元素时
  - 1.7
    - 插入后超过阈值则扩容
    - 将key和value封装为entry对象
    - 头插法插入到当前节点下链表的头部（扩容死链出现的原因）

  - 1.8
    - 插入前超过阈值或链表长度大于8时则扩容
    - 判断当前位置下是链表还是红黑树
      - 链表：将entry尾插，节点数大于8转换为红黑树
      - 红黑树：将node插入
- 常见问题
  - HashMap用红黑树？为什么不用AVL树 
    - 用树结构主要是用来避免DoS攻击，防止链表超长时性能下降

    - 红黑树插入删除快，AVL慢，因为AVL旋转次数更多，平衡和调试更难，但AVL读取快，适合读取密集型任务

  - HashMap红黑树何时会退化？
    - 当因为扩容时导致树的节点少于6时会退化为链表

    - 当删除树的节点时，主要看root，root.left，root.right，root.left.left
      - 如果删除前以上节点还存在则不会退化为链表，反之退化

  - HashMap树化阈值为什么为8？
    - hash值如果足够随机，则在hash表内按泊松分布，在负载因子为0.75的情况下，链表长度超过8的概率为 6*10^-7^ 

  - 索引如何计算？
    - 计算对象的hashCode()，再调用HashMap的hash()方法进行第二次哈希运算，最后 & (容量 - 1) 得到索引
      - 二次哈希值 = 原始哈希code ^ 原始哈希code>>>16
      - 注意这里的容量必须是2的n次幂

  - 已经有hashCode方法为什么还要提供hash方法？
    - 为了使哈希分布更加均匀，减少哈希碰撞

  - 容量为何是2的n次幂？
    - 在HashMap中进行二次hash时可以用按位与运算代替掉取模运算，从而提升一定的计算性能
    - 容量是2的n次幂存在一个问题，当要存储的元素奇偶分布不均时，哈希分布就不那么均匀了
    - 把容量设置为一个质数可以解决这个问题

    - 设置为质数可以在第一次hash时就能有不错的散列分布

    - 如果想要好的性能则选2的n次幂，想要更好的散列分布则选质数

  - 扩容时如何确定新位置？
    - 1.8才有的优化
      - 在扩容时会将元素的二次hash值 和 未扩容前的原始容量 进行按位与（**&**）运算
        - 如果结果为0，表示这些元素扩容后位置不会发生改变
        - 如果结果不为0，则表示这些元素将移动到新的位置

        - 新的位置 = 原始位置 + 原始容量

      - 会把结果为0的和结果不为0的串成两条链表，批量操作

  - 扩容因子为什么默认是0.75？ 
    - 在空间占用和查询时间之间取得较好的平衡

    - 大于这个值，空间节省了，但是链表较长影响性能

    - 小于这个值，冲突减少了，但链表扩容频繁，空间占用多

  - 多线程下hashMap存在什么问题？
    - jdk7有扩容死链问题
      - 是因为1.7扩容后的链表会以头插法插入
      - 当多个线程同时进行扩容时，一个线程扩容后次序改变了，另一个线程再扩容导致死链

     - jdk8有数据丢失问题
       - 当多个线程同时往map的同一个位置存放数据时，容易出现覆盖丢失数据


#### LinkedHashMap

- 非线程安全，有序，可null
- 底层是哈希表+双向链表（存储顺序）

#### HashTable

- 单线程，线程安全，速度慢，不可null
- 底层是哈希表
- 初始容量是11，每次扩容是：容量 × 2 + 1，因为容量为质数有较好的hash分布

#### TreeMap

- 不能重复，有序，非线程安全
- 底层红黑树

#### WeakHashMap

- key是弱引用，gc时回收

## Stream流

### 函数式接口

- Comparator\<T>：
- Supplier\<T>：返回一个指定类型的数据
- Consumer\<T>：用于消费数据
- Predicate\<T>：对数据进行判断
- Function\<T,R>：将一个类型的数据转换为另一个类型的数据

### 方法

| 方法                   | 作用                   | 备注                                             |
| ---------------------- | ---------------------- | ------------------------------------------------ |
| Stream()               | 将集合转换为流         |                                                  |
| Stream.of(数组)        | 将集合转换为流         |                                                  |
| reduce()               | 实现聚合计算，求和     |                                                  |
| mapToXXX()             | 映射为对应的类型       |                                                  |
| orElse() / orElseGet() | 找不到值则返回给定的值 | 使用方法时，即使没有值，也会执行 orElse 内的方法 |
| Collect                | 收集为指定类型的集合   |                                                  |



## 动态代理

- 为一个类创建一个代理类，这个代理类可以调用类中的方法

## SPI机制

​    是Java提供的一种热插拔机制，只要在META-INF目录下定义该类的全路径信息，就可以在Java启动时自动加载对应的类

## API

equals()

- equal是Object 的方法，和他功能相似的是运算符 ==
- == 比较的是地址，equal比较的是值
- == 比较快，== 是运算符
- equal 源码中也是用的 == 进行判断，但是引用类型重写了equals方法
  - 重写需要满足 自反性、对称性、传递性、一致性、非空性

## 类

### Unsafe

- Unsafe提供了非常底层的方法，包括操作内存，线程调度、CAS、系统、内存屏障、对象操作、Class

- 使Java拥有了类似c语言一样的指针，所以不安全

- LookSupport中的unpark也是调用的unsafe的方法

- Unsafe不能直接调用

  - 通过反射获得

    ```
    Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
    theUnsafe.setAccessible(true);
    Unsafe unsafe = theUnsafe.get(null);
    
    Copy
    ```

  - Unsafe提供了一个静态方法getUnsafe可以获取Unsafe实例，但是必须使用引导类加载器加载Unsafe类才能使用，因为有CallerSensitive注解标注，为危险方法

    - 命令行中输入：`java -Xbootclasspath/a: ${path} // 其中path为调用Unsafe相关方法的类所在jar包路径`