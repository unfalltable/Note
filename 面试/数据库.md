## MySQL

- [ ] count(*)、count(1)、count(字段) 对比

- [ ] 索引

  - [ ] 失效情况

  - [ ] 索引下推

  - [ ] 自增id和uuid的区别

- [ ] 连接查询 on 条件判断类型不同怎么判断

- [ ] in查询参数太多怎么办

  - 创建临时表，in后接子查询该临时表

- [ ] InnoDB、MyISAM、Memory区别

- [ ] InnoDB如何解决幻读问题

  - 间隙锁和临键锁

- [ ] 一条sql的执行过程

- [ ] B+tree的能存放的数据有多少

  - 假设一行数据的大小为1k，一个结点可以存放16行这样的数据，InnoDB的指针占6字节，主键假设为bigint，占用8字节
  - 高度2：即一个主键，第二层都是叶子结点
    - n * 8 + (n + 1) * 6 = 16 * 1024 
    - n = 1170
    - 1171 * 16 = 18736
  - 高度3：
    - 1171 * 1171 * 16 = 21939856

- [ ] 查询计划

- [ ] 定位慢查询

- [ ] B数和B+树的区别

- [ ] redo log 两阶段提交过程

- [ ] MySQL三种log日志以及作用

- [ ] 开启事务的完整过程

- [ ] 数据库三范式是什么

  - 第一范式：属性不可再分割
  - 第二范式：有主键，而且其他字段要依赖主键
  - 第三范式：消除传递依赖

- [ ] 悲观锁和乐观锁

  - 悲观锁：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。

  - 乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量

- [ ] 树形表如何查询

  - 树形表一般都会建立一个标记字段，例如parent_id

  - 使用表的自链接查询，向下递归

    ``` sql
    select * from t t1 inner join t t2 on t1.id = t2.parent_id
    ```

  - 向上递归

    ```sql
    with recursive t1 as{
    	select * from t t2 where id = '1-1-1'
    	union all 
    		select t3.* from t t3 inner join t1 on t1.parent_id = t3.id
    }
    select * from t1 order by t1.id
    ```

- [ ] 最左前缀法则怎么优化order by

  - 只传入必要的查询字段、过滤字段、排序字段，并为这些字段建立索引

- [ ] MVCC

  - [ ] 实现

- [ ] 可重复读

  - [ ] 怎么实现
  - [ ] 出现幻读的情况
    - 更新一个查不到的数据
    - 一个查（没用for update），一个加，再查就幻读了
  - 用for update 避免

- [ ] Next Key Lock（行锁+间隙锁）

  - [ ] 底层
    - 锁一个记录的一个范围
    - 前开后闭
    - 先加间隙锁，然后才加行锁
    - 对非索引字段的加间隙锁，会导致锁表

- [ ] 主从延迟

  - [ ] 怎么解决
    - 设置延迟读取
    - 忍受大法
    - 数据库同步写方案
    - 选择性强制读主
    - 中间件选择路由法
    - 缓存路由大法

- [ ] undo log binlog

- [ ] BufferPool

  - [ ] 如何管理Page页

- [ ] ChangeBuffer

  - [ ] 为什么仅适用于非唯一普通索引

- [ ] 当前读和快照读

- [ ] 锁

  - [ ] 行锁、表锁、页锁
  - [ ] 读锁、写锁
  - [ ] 乐观锁、悲观锁
  - [ ] 共享锁、排他锁

## Redis

- [ ] 哪些场景使用了Redis
- [ ] Redis内存用完了会发生什么
  - 不同的内存淘汰策略会发生的情况不同
- [ ] 如何保证缓存与数据库一致性
- [ ] redis防止表单重复提交是怎么实现的
- [ ] Redis内存满了 / 内存不够用