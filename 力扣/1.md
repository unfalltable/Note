---
title: 代码随想录
categories: 算法题
tags: [数据结构和算法,代码随想录]
---

| 题目                         | 提示                                                         | 备注                                                         |
| :--------------------------- | ------------------------------------------------------------ | :----------------------------------------------------------- |
| 二分查找                     | 找最左最右 <br/>while循环中的if判断目标值不能等于            | 有找最左最右值的                                             |
| 移除元素                     | 从左到右遍历数组，满足目标值则于最右交换                     | 原地删除，返回删除后长度                                     |
| 有序数组的平方               | 双指针分别指向首尾，比较后放进结果数组                       | 有负有序数组，平方后排序                                     |
| 长度最小的子数组             | 双指针，右指针从0往右走，sum+=right的值，当sum>=target时，记录right-left的值，然后sum-left的值，left++ | 子数组大于等于目标值的长度                                   |
| 螺旋矩阵II                   | 模拟过程，定义left，right，top，bottom                       | n x n 的正方形                                               |
| 移除链表元素                 | 创建头节点，node.next = head; res = node; 操作res即可        | 删除链表中值为val的节点                                      |
| 设计链表                     | 模拟过程                                                     |                                                              |
| 两两交换链表中的节点         | 创建一个虚拟头结点，tmp.next = head;                         | A -> B -> C -> D<br />B -> A -> D -> C                       |
| 删除链表的倒数第N个节点      | 建立头结点temp指向head，创建快慢指针指向temp，创建pre记录slow的前一位，fast先走n步，slow再和fast一起走，直到fast为null，然后pre.next = pre.next.next | 给定一个链表，删除其倒数第k个节点                            |
| 链表相交                     | 一：算两链表差值<br />二；一起走，到头跳到另一条链表         | 两链表会有一段合并的                                         |
| 有效的字母异位词             | 用一个数组保存每一个字母出现的次数                           | 判断两个字符串的字母和出现次数是否一致                       |
| 两个数组的交集               | 用两个set，一个填充后另一个过滤                              |                                                              |
| 快乐数                       | 判断是否有重复的元素，有重复即发生了循环，用set存放每次的结果， | 给一个数，循环每一位的平方相加，最后等于1即是快乐数          |
| 两数之和                     | 使用哈希表解决，将数值的值和下标封装到map中，值 ：下标 的形式 | 找数组中和为target的两个数的下标                             |
| 四数相加                     | 双重for循环将 a + b : 出现的次数  加入map中，双重for统计 c + b = - (a + b) 的次数 | 给四个数组，找 a + b + c + d = 0，返回满足的次数             |
| 三数之和 / 四数之和          | 取一个为基准，然后就类似两数之和了，进行一些剪枝操作<br />a为基准，b = a + 1, c 是最后一位，但b < c 时循环找 | 给一个数组，找a + b + c = 0                                  |
| 反转字符串                   | 双指针指首尾，交换值                                         | abc -> cba                                                   |
| 反转字符串Ⅱ                  | 模拟过程，可用异或优化                                       | 给定一个字符串s和整数k，到2k位置就反转前k个字符              |
| 替换空格                     | ⅠStringBuilder实现<br />Ⅱ 创建一个新数据将' '填充为'   ',然后与旧数组的值对比 | 字符串中的空字符替换                                         |
| 翻转字符串里的单词           | Ⅰ转换为单词数组，从尾向头遍历<br />Ⅱ api                     |                                                              |
| 左旋转字符串                 |                                                              |                                                              |
| **实现Strstr()**             | KMP算法，求s2的next数组（next数组记录的是s2每个位置之前的序列头尾相等的个数），在s1中匹配s2时，不相等时s2跳到next对应的位置 | 给定s1，s2，求s2在s1的开始下标                               |
| 重复的字符串                 |                                                              |                                                              |
| 二叉树层序遍历               | 用队列存储节点，一个集合存放每一层的节点，一点存放总的节点   | 自顶向下，<br />自底向上<br />Z型遍历                        |
| 翻转二叉树                   | 递归+后序遍历                                                |                                                              |
| 对称二叉树                   | 把树看出左右两棵树，判断左孩子是否等于右孩子                 | 判断树是否是轴对称                                           |
| 二叉树的深度                 | 递归 / 层序遍历                                              | 最大最小深度                                                 |
| 完全二叉树节点个数           | 计算左右子树，一直找左孩子就是树的高度                       |                                                              |
| 平衡二叉树                   | 递归判断左右高度差                                           |                                                              |
| 二叉树的所有路径             | 遍历                                                         |                                                              |
| 相同的树                     | 遍历                                                         | 判断两棵树是否一样                                           |
| 左叶子之和                   |                                                              |                                                              |
| 找树左下角的值               |                                                              |                                                              |
| 路径总和                     |                                                              |                                                              |
| 构造二叉树                   |                                                              | 中序、后序<br />前序、中序                                   |
| 最大二叉树                   |                                                              |                                                              |
| 合并二叉树                   |                                                              |                                                              |
| 二叉搜索树中的搜索           |                                                              |                                                              |
| 二叉搜索树的最小绝对差       |                                                              |                                                              |
| 验证二叉搜索树               |                                                              |                                                              |
| 二叉树中的众数               |                                                              |                                                              |
| 二叉树的最近公共祖先         | Ⅰ：使用map和set，map记录父节点，set记录路径<br />Ⅱ：递归查找左右子树是否有目标节点 | 找到两个节点的汇聚节点                                       |
| 二叉搜索树的最近公共祖先     |                                                              |                                                              |
| 二叉搜索树中的插入操作       |                                                              |                                                              |
| 删除二叉搜索树中的节点       |                                                              |                                                              |
| 修剪二叉搜索树               |                                                              |                                                              |
| 将有序数组转换为二叉搜索树   |                                                              |                                                              |
| 把二叉搜索树转换为累加树     |                                                              |                                                              |
| 用栈实现队列                 | 一个输入栈一个输出栈                                         |                                                              |
| 用队列实现栈                 | 链表实现                                                     |                                                              |
| 有效的括号                   | 左括号入栈，然后出栈判断，最后栈空为有效                     | 判断字符串左右括号是否有效                                   |
| 删除字符串中的所有相邻重复项 |                                                              |                                                              |
| 逆波兰表达式求值             |                                                              |                                                              |
| 滑动窗口的最大值             |                                                              |                                                              |
| 前k个高频元素                |                                                              |                                                              |
| 组合问题                     | 写一个dfs方法深度遍历，用一个results放全部结果，用result存放单次的结果 <br />当result的大小满足条件就加入results中<br />for循环时添加元素，回溯时删除result的最后一位 | 回溯 + 剪枝                                                  |
| 组合总和问题                 |                                                              |                                                              |
| 电话号码组合问题             |                                                              |                                                              |
| 分割回文串                   |                                                              |                                                              |
| 复原ip地址                   |                                                              |                                                              |
| 子集问题                     |                                                              |                                                              |
| 递增子序列                   |                                                              |                                                              |
| 全排列问题                   |                                                              |                                                              |
| 重新安排行程                 |                                                              |                                                              |
| N皇后                        |                                                              | 不能同行同列同对角                                           |
| 解数独                       |                                                              |                                                              |
| 分发饼干                     |                                                              |                                                              |
| 摆动序列                     |                                                              |                                                              |
| 最大子序和                   | 一个全局最大sum一个尝试的count，加进去大就保留               | 找最大的连续的子数组                                         |
| 跳跃游戏问题                 | Ⅰ：<br />     从前往后：每到一步获取能到的最远的一步<br />Ⅱ：<br />     从后往前：最后一位跳到他能到的最远的位置，步数加一 <br />     从前往后: 每走一步都判断能到的最远距离，判断当前是否到达最远位置 | 从数组第一位跳到最后一位<br />Ⅰ 能否到达最后一位<br />Ⅱ 最少次数到达 |
| K次取反后最大化的数组和      |                                                              |                                                              |
| 加油站                       |                                                              |                                                              |
| 分发糖果                     | 用一个left数组记录第一位与其后一位是否呈递增关系，用一个right数组记录最后一位与其前一位是否呈递增关系，取left和right大的为糖果数（站一圈需要找到局部最小值填充数组两边，用线性的方式计算然后-1） | 小孩站一排，发糖果，分高的多得，求最少总糖果数（扩展为站一圈） |
| 柠檬水找零                   | 统计5元和10元的数量，小于0则false，判断三种情况，支付20的时候需要判断是否有10元，没10元用三张5元， | 一杯柠檬水5元，客户可给5，10，20，正确找零                   |
| 根据身高重建队列             | [a, b]，先将区间按a从大到小排列，然后插入指定b的位置         | [a, b] a是身高，b是当前身高之前的人数，从小到大排列          |
| 用最少数量的箭引爆气球       | 假设n个气球需要n支箭，有区间重合就减一支箭                   | 气球在x轴上排列，相当于一个个区间，类似于将他们合并为最少数量的区间 |
| 无重叠区间                   | 先排序，遍历数组，记录前一个区间的右边界，每次判断当前区间左边界是否大于上一个区间的右边界，小于则结果+1 | 给定一些区间，查找重复区间的个数                             |
| 划分字母区间                 | last数组记录每个字母最后出现的位置，当循环位置到达最后出现位置是计算结果 | 将字符串s划分，每个片段中的值在另一个片段不存在              |
| 合并区间                     | 比较[ i ]\[ 0 ] 和 [ i - 1 ]\[ 1 ] 的大小，最后记得添加最后一个区间到结果中 | 合并重复的区间，[1,3] [2,6]=[1,6]                            |
| 单调递增的数字               | 将n转为char数组，从倒数第二和倒数第一开始比较，后大于前则减一，记录这一位的位置，从这位开始都变9就是答案 | 找到一个小于等于N的数，其每个位置是单调递增的                |
| 监控二叉树                   | 0 表示无覆盖 ，1 表示有摄像头，2 表示有覆盖，左右孩子都为2返回0，左右其中一个0返回1，监控数+1，覆盖的返回2 | 每个节点可监视其父对象、自身及其直接子对象，求需要监控个数   |
| 斐波那契                     | dp[n] = d[n-1] * dp[n-2]                                     |                                                              |
| 爬楼梯                       | Ⅰ：dp[n] = d[n-1] * dp[n-2] 或 三个变量<br />Ⅱ：算最小代价从，dp[i] = Math.min(dp[i - 2], dp[i - 1]) + cost[i] | Ⅰ：一次跳1或2，爬法<br />Ⅱ：层台阶都有代价                   |
| 不同路径                     | Ⅰ：dp\[i][j] = dp\[i-1][j] + dp\[i][j-1];<br />Ⅱ：当前位置不能走则设为0即可 | Ⅰ：左上走到右下<br />Ⅱ：有些路不能走                         |
| 整数拆分                     |                                                              |                                                              |
| 不同的二叉搜索树             |                                                              |                                                              |
| 分割等和子集                 |                                                              |                                                              |
| 最后一块石头的重量           |                                                              |                                                              |
| 目标和                       |                                                              | 给一个nums和target，元素之间可以加减，算能达到target的组合个数 |
| 一和零                       |                                                              |                                                              |
| 零钱问题                     | Ⅰ：双重for dp[rest] = Math.min(dp[rest], dp[rest - coins[index]] +1) <br />Ⅱ：双重for dp[j] += dp[j - coins[i]] | Ⅰ：花费最少的硬币数<br />Ⅱ：组合的个数                       |
| 组合总和Ⅳ                    |                                                              |                                                              |
| 完全平方数                   |                                                              |                                                              |
| 单词拆分                     |                                                              |                                                              |
| 最长递增子序列               | 双重for 判断之前位是否有小于当前位置值的，有则+1，最大值即是结果<br />每走一格就要刷新整个dp数组 | 给一个数组，找最长递增子序列，不用连续                       |
| 最长连续递增序列             | dp判断当前值是否大于前一位，是+1，否等于1，返回dp最大值即可  | 找最长连续递增子序列                                         |
| 最长公共子序列               | 二维数组保存相等个数，如果当前位置相等，则等于dp[i-1]\[j-1] + 1，不相等则左边和上边取大值 | 找两个字符串公共子序列长度                                   |
| 不相交的线                   |                                                              |                                                              |
| 最大子序和                   | 贪心：count当前最大值，sum全局最大值，count < 0 时令其等于0<br />动规：dp[0] = nums[0] , ans = dp[0]，循环dp[i] = Math.max(dp[i-1] + nums[i], nums[i]); | 给你一个整数数组 nums ，找出一个具有最大和的连续子数组，返回其最大和 |
| 判断子序列                   |                                                              |                                                              |
| 不同的子序列                 |                                                              |                                                              |
| 两个字符串的删除操作         |                                                              |                                                              |
| 编辑距离                     |                                                              |                                                              |
| 回文子串                     |                                                              | 求正反相同的字符串个数                                       |
| 最长回文子序列               |                                                              | 返回长度                                                     |
| 打家劫舍                     | Ⅰ Math.max(dp[i - 1], dp[i - 2] + nums[i])<br />Ⅱ 拆成0 - n-2 和 1 - n-1<br />Ⅲ | 给一个数组，求最大sum<br />Ⅰ不能抢相邻的<br />Ⅱ 围成一圈<br />Ⅲ 树形 |
| 买卖股票问题                 | i-天数    k-次数    0没股票    1有股票<br />1.dp\[i][0] = Math.max(dp\[i-1][0], dp\[i-1][1] + prices[i]);<br/>   dp\[i][1] = Math.max(dp\[i-1][1], -prices[i]);<br />2.dp\[i][0] = Math.max(dp\[i-1][0], dp\[i-1][1]+prices[i]);<br/>   dp\[i][1] = Math.max(dp\[i-1][1], dp\[i-1][0]-prices[i]);<br />3 and 4.需要先给每个k赋初值<br />   dp\[i]\[k][0] = Math.max(dp\[i-1]\[k][0], dp\[i-1]\[k][1] + prices[i]);<br/>   dp\[i]\[k][1] = Math.max(dp\[i-1]\[k][1], dp\[i-1]\[k-1][0]-prices[i]);<br />5.需要先给前两天赋初值<br />   dp\[i][0] = Math.max(dp\[i-1][0], dp\[i-1][1]+prices[i]);<br/>   dp\[i][1] = Math.max(dp\[i-1][1], dp\[i-2][0]-prices[i]); <br />6.dp\[i][0] = Math.max(dp\[i-1][0], dp\[i-1][1]+prices[i] - fee);<br/>   dp\[i][1] = Math.max(dp\[i-1][1], dp\[i-1][0]-prices[i]); | 一次交易<br />无限制<br />两次<br />k次<br />有冷冻期<br />有手续费 |
| 每日温度                     | 下标入栈，遇到大于下标对应值的，计算差值                     | 给定一个温度数组，找比当前温度高的，计算间隔                 |
| 下一个最大的数               | Ⅰ：数组二从后往前遍历入栈，当前数如果大于栈顶元素则出栈，用map存储当前元素和栈顶元素<br />Ⅱ：for循环size的两倍并将 i%size入栈，while循环栈不为空并且 nums[i % size] > nums[st.peek()]，然后result[st.peek()] = nums[i % size] | Ⅰ：给两个数组，在数组二中找比数组一x大的数，一是二的子集<br />Ⅱ：给一个循环数组，返回每个位置下个更大的数 |
| 接雨水                       | 双指针                                                       | 给一个数组表示高度，除头尾元素，之间高度差为储水量，求总储水量 |
| 柱状图中最大的矩形           |                                                              |                                                              |

# 数组

## 	二分查找

### 二分查找

```java
//找中间值
public int search(int[] nums, int target) {
    //定义左右边界
    int low = 0, high = nums.length - 1;
    while (low <= high) {
        //防止整型溢出
        int mid = (high - low) / 2 + low;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] > target) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return -1;
}
```

---

### 查找最左边出现的目标值

```java
public int search(int[] nums, int target) {
    int low = 0, high = nums.length - 1;
    while (low <= high) {
        int mid = (high - low) / 2 + low;
        if (nums[mid] > target) {
            high = mid - 1;
        } else if (nums[mid] < target) {
            low = mid + 1;
        } else{
            high = mid;
        }
        //low等于目标值时就是最左边满足条件的值
        if(arr[low]==target) return low;
    }
    return -1;
}
```

### 查找最右边出现的目标值

```java
public static int searchRight(int[] nums, int target) {

    int low = 0, high = nums.length - 1;
    while (low <= high) {
        int mid = (high - low) / 2 + low;
        if (nums[mid] > target) {
            high = mid - 1;
        } else if (nums[mid] < target) {
            low = mid + 1;
        }else{
            low = mid + 1;
        }
        //high等于目标值时就是最左边满足条件的值
        if(nums[high]==target) return high;
    }
    return -1;
}
```

## 移除元素

[力扣题目链接](https://leetcode-cn.com/problems/remove-element/)

```java
/*
	题目：
	- 原地移除数组中等于val的元素
	- 返回新数组的长度
	思路：
	- 定义两个指针，分别指向数组两端，
	- 遇到等于val的元素将它和数组中最后的元素交换
*/
public int removeElement(int[] nums, int val) {
    int left = 0;
    //为了保证left能取到最后一个
    int right = nums.length;
    while (left < right) {
        if (nums[left] == val) {
            nums[left] = nums[right - 1];
            right--;
        } else {
            left++;
        }
    }
    return left;
}
```

---

## 有序数组的平方

[力扣题目链接](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

```java
/*
	题目：
	- 一个升序排序的数组arr，返回每个数字的平方
	- 组成新的数组，也是升序的
	思路：
	- 定义两个指针，分别指向数组两端，
*/
public int[] sortedSquares(int[] arr) {
    int left = 0, right = arr.length-1;
    int[] resultArr = new int[arr.length];
    int resultIndex = resultArr.length-1;
    while (left <= right){
        if(arr[left]*arr[left] > arr[right] * arr[right]) {
            resultArr[resultIndex--] = arr[left] * arr[left];
            left++;
        }else{
            resultArr[resultIndex--] = arr[right] * arr[right];
            right--;
        }
    }
    return resultArr;
}
```

---

## 长度最小的子数组

[力扣链接](https://leetcode-cn.com/problems/minimum-size-subarray-sum/) 

```java
/*
	题目：
	   给定一个含有 n 个正整数的数组和一个正整数 target
	   找出该数组中满其 和 ≥ target 的长度最小的连续子数组并返回其长度
	   如果不存在符合条件的 子数组，返回 0
	思路：
		滑动窗口
*/
public static int minSubArrayLen(int target, int[] arr) {
    int left = 0, right = 0, sum = 0, min = 0;
    while(right < arr.length){
        sum += arr[right++];
        while(sum >= target){
            if(min == 0){
                min = right - left;
            }else {
                min = Math.min(min, right - left);
            }
            sum -= arr[left++];
        }
    }
    return min;
}
```

---

## 螺旋矩阵II

[力扣题目链接](https://leetcode-cn.com/problems/spiral-matrix-ii/)

```java
/*
	题目：
	- 给定一个n，生成一个包含1到n^2的所有元素的矩阵
	- 			  1 2 3 
	- 假设n=3	=》	8 9 4
	- 			  7 6 5
	思路：
	- 一圈一圈的模拟这个过程 
*/
public static int[][] generateMatrix(int n) {
    int num = 1;
    int[][] arr = new int[n][n];
    //分别指的是四条边
    int left = 0, right = n - 1, top = 0, bottom = n - 1;
    while (left <= right && top <= bottom) {
        for (int i = left; i <= right - 1; ++i) {
            arr[top][i] = num++;
        }
        for (int i = top; i <= bottom - 1; ++i) {
            arr[i][right] = num++;
        }
        for (int i = right;i >= left + 1; --i) {
            arr[bottom][i] = num++;
        }
        for (int i = bottom;i >= top + 1; --i) {
            arr[i][left] = num++;
        }
        left++;
        right--;
        top++;
        bottom--;
    }
    //如果n是奇数矩阵z
    if(n % 2 == 1)
        arr[n/2][n/2] = n*n;
    return arr;
}
```

---

# 链表

## 移除链表元素

[力扣链接](https://leetcode-cn.com/problems/remove-linked-list-elements/)

```java
/*
	思路：
	- 创建一个节点指向head节点
	- 只要判断新节点下一个节点即可
*/
public ListNode removeElements(ListNode head, int val) {
    ListNode node = new ListNode();
    node.next = head;
    ListNode res = node;
    while(res.next != null){
        if(res.next.val == val){
            res.next = res.next.next;
        }else{
            res = res.next;
        }
    }
    return node.next;
}
```

---

## 设计链表

[力扣链表](https://leetcode-cn.com/problems/design-linked-list/) 

```java
/*
	思路：
	- 模拟过程，注意边界处理
*/
class LinkNode{
        int val;
        LinkNode next;
        LinkNode prev;
        LinkNode(int val){this.val = val;}
}
class MyLinkedList {
    int size = 0;
    LinkNode head;
    LinkNode tail;
    LinkNode next, prev, cur;
    public MyLinkedList() {
        head = new LinkNode(0);
        tail = new LinkNode(0);
        head.prev = tail;
        head.next = tail;
        tail.next = head;
        tail.prev = head;
    }
    public int get(int index) {
    if (index < 0 || index >= size) return -1;
        cur = head;
        if (index + 1 < size - index)
            for(int i = 0; i < index + 1; ++i) cur = cur.next;
        else {
            cur = tail;
            for(int i = 0; i < size - index; ++i) cur = cur.prev;
        }
        return cur.val;
    }

    public void addAtHead(int val) {
        LinkNode newNode = new LinkNode(val);
        next = head.next;
        head.next = newNode;
        newNode.prev = head;
        newNode.next = next;
        next.prev = newNode;
        size++;
    }
    public void addAtTail(int val) {
        LinkNode newNode = new LinkNode(val);
        prev = tail.prev;
        next = tail;
        prev.next = newNode;
        newNode.prev = prev;
        newNode.next = next;
        next.prev = newNode;
        size++;
    }
    public void addAtIndex(int index, int val) {
        if(index > size) return;
        if(index < 0) addAtHead(val);
        LinkNode newNode = new LinkNode(val);
        cur = head;
        for (int i = 0; i < index; i++) cur = cur.next;
        next = cur.next;
        cur.next = newNode;
        newNode.prev = cur;
        newNode.next = next;
        next.prev = newNode;
        size++;
    }
    public void deleteAtIndex(int index) {
        if(index >= size || index < 0) return;
        cur = head.next;
        for (int i = 0; i < index; i++) cur = cur.next;
        prev = cur.prev;
        next = cur.next;
        prev.next = next;
        next.prev = prev;
        size--;
    }
}
```

---

## 两两交换链表中的节点

[力扣链接](https://leetcode-cn.com/problems/swap-nodes-in-pairs/) 

```java
/*
	思路：
	- 创建一个头节点
	- 因为在处理节点时会丢失节点的相关属性
*/
public ListNode swapPairs(ListNode head) {
    if(head == null) return null;
    if(head.next == null) return head;
    //创建一个头节点
    ListNode temp = new ListNode(0);
    temp.next = head;
    //res作为返回值
    ListNode res = head.next;
	//当第一个节点和第二个节点不为空时处理
    while(temp.next != null && temp.next.next != null){
        //指向第一个节点
        ListNode node1 = temp.next;
        //指向第二个节点
        ListNode node2 = temp.next.next;
        //执行交换操作
        temp.next = node2;
        node1.next = node2.next;
        node2.next = node1;     
        temp = node1;
    }
    return res;
}
```

## 删除链表的倒数第N个节点

[力扣链接](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/) 

```java
/*
	思路：
	- 创建一个头结点指向head
	- 创建快慢指针和pre指针
	- fast先走 n 步，slow再走，记录slow的pre
	- pre.next = slow.next
	- slow == null;
	- 返回tmp.next
*/
public ListNode removeNthFromEnd(ListNode head, int n) {
    if(head == null || head.next == null) return null;
    ListNode tmp = new ListNode();
    tmp.next = head;
    ListNode slow = tmp;
    ListNode fast = tmp;
    ListNode pre = null;
    while(n-- > 0){
        fast = fast.next;
    }
    while(fast != null){
        pre = slow;
        slow = slow.next;
        fast = fast.next;   
    }
    pre.next = pre.next.next;
    slow = null;
    return tmp.next;
}
```

## 链表相交

[力扣链接](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/) 

```java
/*
	题目：
	- 给定两个链表，找到两链表相交的第一个节点，没有则返回null
	- 两链表均无环
	思路：
	- 方法一
		- 计算两链表长度的差值，长的链表先走差值步，然后两链表一起走
	- 方法二
		- 两链表一起走，到尾的一边就跳到另外一条链表的头
*/
//方法二
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    ListNode A = headA, B = headB;
    while(A != B){
        A = A != null ? A = A.next : headB;
        B = B != null ? B = B.next : headA;
    }
    return A;
}
```

# 哈希表

## 有效的字母异位词

[力扣链接](https://leetcode-cn.com/problems/valid-anagram/) 

```java
/*
	题目：
	- 给定两个字符串 s 和 t 
	- 判断 t 是否是 s 的字母异位词
	- 即判断两个字符串字母和个数是否一致
	思路：
	- 方法一
		- 将两个字符串转为数组并排序
	- 方法二
		- 用一个数组保存每一个字母出现的次数
*/
public boolean isAnagram(String s, String t) {
    if(s.length() != t.length()) return false;
    int[] index = new int[26];
    for(int i = 0; i < s.length(); ++i){
        index[s.charAt(i) - 'a']++;
    }
    for(int i = 0; i < t.length(); ++i){
        if(index[t.charAt(i) - 'a'] > 0){
            index[t.charAt(i) - 'a']--;
        }else{
            return false;
        }
    }
    return true;    
}
```

---

## 两个数组的交集

[力扣链接](https://leetcode-cn.com/problems/intersection-of-two-arrays/) 

```java
/*
	思路：
	- 用两个set，一个填充后另一个过滤
	- 或者用Collection中的retainAll
		- 仅保留此 collection 中那些也包含在指定 collection 的元素
*/
public int[] intersection(int[] nums1, int[] nums2) {
    Set<Integer> set1 = new HashSet<>();
    Set<Integer> set2 = new HashSet<>();      
    for(int i:nums1){
        set1.add(i);
    }
    for(int i:nums2){
        if(set1.contains(i)){
            set2.add(i);
        }
    }
    int[] arr = new int[set2.size()];
    int j=0;
    for(int i:set2){
        arr[j++] = i;
    }
    return arr;
}
```

---

## 快乐数

[力扣](https://leetcode-cn.com/problems/happy-number/) 

```java
/*
	题目
	- 给一个数，循环每一位的平方相加，结果为1即是快乐数
	思路
	- 判断是否有重复的元素，有重复即发生了循环
	- 不可能有无限大的情况，最999也只会是243
*/
public static boolean isHappy(int n) {
    Set<Integer> set = new HashSet<>();
    while(n != 1 && !set.contains(n)){
        set.add(n);
        n = change(n+"");
    }
    return n == 1;
}
public int change(String n) {
    int sum = 0;
    for(int i = 0; i < n.length(); ++i){
        sum+=(n.charAt(i) - '0') * (n.charAt(i) - '0');
    }
    return sum;
}
//方法二（快慢指针）
public boolean isHappy(int n) {
    int slow = n;
    int fast = change(n+"");
    while (fast != 1 && slow != fast) {
        slow = change(slow+"");
        fast = change(change(fast)+"");
    }
    return fast == 1;
}
```

## 两数之和

```java
/*
	使用哈希表解决
	将数值的值和下标封装到map中
	值 = 下标 的形式
*/
for (int i = 0; i < arr.length; ++i) {
    if(map.containsKey(target-arr[i]))
        return new int[]{map.get(target-arr[i]),i};
    map.put(arr[i],i);
}
```

## 四数相加

[力扣](https://leetcode-cn.com/problems/4sum-ii/) 

```java
/*
	思路
	- a + b 存入 map 
	- key：a+b   
	- value：出现的次数
	- 在map找-(c + d)，有就将其value加入次数
*/
public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
    Map<Integer,Integer> map = new HashMap<>();
    int tmp = 0, count = 0;
    for(int i : nums1){
        for(int j : nums2){
            map.put(i + j, map.getOrDefault(i + j,0)+1);
        }
    }
    for(int i : nums3){
        for(int j : nums4){
            if(map.containsKey(0 - i - j))
                count += map.get(-i-j);
        }
    }
    return count;
}
```

## 三数之和

[力扣](https://leetcode-cn.com/problems/3sum/) 

```java
/*
	- 取一个为基准，然后就类似两数之和了，进行一些剪枝操作
*/
public List<List<Integer>> threeSum(int[] nums) {
    Arrays.sort(nums);
    List<List<Integer>> results = new ArrayList<>();

    for(int a = 0; a < nums.length - 2; ++a){
        if(nums[a] > 0) return results;
        if (a > 0 && nums[a] == nums[a - 1]) continue;

        int b = a + 1;
        int c = nums.length - 1;
        while(b < c){
            int sum = nums[a] + nums[b] + nums[c];
            if (sum > 0) {
                c--;
            } else if (sum < 0) {
                b++;
            } else {
                results.add(Arrays.asList(nums[a], nums[b], nums[c]));
                while (c > b && nums[c] == nums[c - 1]) c--;
                while (c > b && nums[b] == nums[b + 1]) b++;
                c--;
                b++;
            }
        }
    }
    return results;
}
```

## 四数之和

[力扣](https://leetcode-cn.com/problems/4sum/) 

```java
/*
	- 与三数之和解法类似
*/
public List<List<Integer>> fourSum(int[] nums, int target) {
    Arrays.sort(nums);
    List<List<Integer>> result = new ArrayList<>();

    for(int a = 0; a < nums.length - 3; ++a){
        for(int b = a + 1; b < nums.length - 2; ++b){
            int c = b + 1;
            int d = nums.length - 1;
            while(d > c){
                int sum = nums[a] + nums[b] + nums[c] + nums[d];
                if(sum < target){
                    c++;
                }else if(sum > target){
                    d--;
                }else{
                    List<Integer> tmp 
                        = Arrays.asList(nums[a], nums[b], nums[c],nums[d]);
                    if(!result.contains(tmp)){
                        result.add(tmp);
                    }
                    c++;
                    d--;
                }
            }
        }
    }
    return result;
}
```

# 字符串

## 反转字符串

[力扣链接](https://leetcode-cn.com/problems/reverse-string/) 

```java
/*
	思路：
	- 双指针指向两端，交换位置
*/
public void reverseString(char[] s) {
    int i = 0;
    int j = s.length-1;
    for (;i<j;++i,--j){
        char temp = s[i];
        s[i] = s[j];
        s[j] = temp;
    }
}
```

## 反转字符串Ⅱ

[力扣链接](https://leetcode-cn.com/problems/reverse-string-ii/) 

```java
/*
	题目：
	- 给定一个字符串s和整数k，到2k位置就反转前k个字符
		- 如果剩余字符少于 k 个，则将剩余字符全部反转。
		- 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符。
	思路：
	- 方法一：模拟过程
	- 方法二：
*/
//解法一
public String reverseStr(String s, int k) {
    char[] ch = s.toCharArray();
    // 1. 每隔 2k 个字符的前 k 个字符进行反转
    for (int i = 0; i< ch.length; i += 2 * k) {
        // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符
        if (i + k <= ch.length) {
            reverse(ch, i, i + k -1);
            continue;
        }
        // 3. 剩余字符少于 k 个，则将剩余字符全部反转
        reverse(ch, i, ch.length - 1);
    }
    return  new String(ch);
}
// 定义翻转函数
public void reverse(char[] ch, int i, int j) {
    for (; i < j; i++, j--) {
        char temp  = ch[i];
        ch[i] = ch[j];
        ch[j] = temp;
    }
}
//解法二
public String reverseStr(String s, int k) {
    char[] ch = s.toCharArray();
    for(int i = 0; i < ch.length; i += 2 * k){
        int start = i;
        //这里是判断尾数够不够k个来取决end指针的位置
        int end = Math.min(ch.length - 1, start + k - 1);
        //用异或运算反转 
        while(start < end){
            ch[start] ^= ch[end];
            ch[end] ^= ch[start];
            ch[start] ^= ch[end];
            start++;
            end--;
        }
    }
    return new String(ch);
}
```

## 替换空格

[力扣链接](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/) 

```java
//方法一，StringBuilder
public String replaceSpace(String s) {
    StringBuilder sb = new StringBuilder(s);
    int i = 0;
    while(i < sb.length()){
        if(sb.charAt(i) == ' '){
            sb.deleteCharAt(i);
            sb.insert(i, "%20");
        }
        i++;
    }
    return sb.toString();
}
//方式二：双指针法
public String replaceSpace(String s) {
    int len = s.length();
    if(s == null || len == 0){
        return s;
    }
    //扩充空间，空格数量2倍
    for (int i = 0; i < len; i++) {
        if(s.charAt(i) == ' '){
            s = s + "  ";
        }
    }
    if(len == s.length()){
        return s;
    }
    //有空格情况 定义两个指针
    int left = len - 1;//左指针：指向原始字符串最后一个位置
    int right = s.length()-1;//右指针：指向扩展字符串的最后一个位置
    char[] chars = s.toCharArray();
    while(left>=0){
        if(chars[left] == ' '){
            chars[right--] = '0';
            chars[right--] = '2';
            chars[right] = '%';
        }else{
            chars[right] = chars[left];
        }
        left--;
        right--;
    }
    return new String(chars);
}
```

## 翻转字符串里的单词

[力扣](https://leetcode-cn.com/problems/reverse-words-in-a-string/) 

```java
/*
	题目
	- 
	思路
	- 
*/
public String reverseWords(String s) {
	s = s.trim();
    String[] str = s.split("\\s+");
    String res = "";
    for(int i = str.length - 1; i >= 0; --i){
        if(i == 0){
            res += str[i];
            break;
        }
        res += str[i] + " ";
    }
    return res;
}
//使用api
public String reverseWords(String s){
    // 除去开头和末尾的空白字符
    s = s.trim();
    // 正则匹配连续的空白字符作为分隔符分割
    List<String> wordList = Arrays.asList(s.split("\\s+"));
    Collections.reverse(wordList);
    return String.join(" ", wordList);
}
```

## 左旋转字符串

[力扣](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/) 

```java
/*
	题目
	- 
	思路
	- 
*/
//使用api
 public String reverseLeftWords(String s, int n) {
     return s.substring(n) + s.substring(0, n);
 }
//只用String
public String reverseLeftWords(String s, int n) {
    String res = "";
    for(int i = n; i < s.length(); i++)
        res += s.charAt(i);
    for(int i = 0; i < n; i++)
        res += s.charAt(i);
    return res;
}
```

## 实现strStr()

[力扣](https://leetcode-cn.com/problems/implement-strstr/) 

```java
//求哈希相等的
public int strStr(String haystack, String needle) {
    if(needle.length() > haystack.length()) return -1;
    int numStr2 = 0;
    int str2Len = needle.length();
    Map<Integer, Integer> str1 = new HashMap<>();
    for (char str : needle.toCharArray()) {
        numStr2 += str - 'a';
    }
    int index = 0;
    for (int j = 0; j < haystack.length();) {
        str1.put(index, haystack.charAt(j) - 'a');
        for (int i = j+1; i < j + str2Len && i < haystack.length() ;i++) {
            if(str1.get(index) > numStr2) break;
            str1.put(index, str1.get(index) + haystack.charAt(i) - 'a');
        }
        j++;
        if (haystack.length() - j < str2Len) {
            break;
        }
        index++;
    }
    for (Map.Entry<Integer, Integer> entry : str1.entrySet()) {
        if (entry.getValue() == numStr2){
            int k = entry.getKey();
            int i = 0;
            while(i < str2Len){
                if (haystack.charAt(k++) == needle.charAt(i)){
                    i++;
                }else{
                    break;
                }
            }
            if(i == str2Len) return entry.getKey();
        }
    }
    return -1;
}

//KMP
public int strStr(String haystack, String needle) {
    int[] next = getNext(needle);
    int s1 = 0;
    int s2 = 0;
    while(s1 < haystack.length() && s2 < needle.length()){
        if(haystack.charAt(s1) == needle.charAt(s2)){
            s1++;
            s2++;
        }else if(next[s2] == -1){
            s1++;
        }else{
            s2 = next[s2];
        }
    }
    return s2 == needle.length() ? s1-s2 : -1;
}
public int[] getNext(String str){
    if(str.length() == 1) return new int[]{-1};
    int[] res = new int[str.length()];
    res[0] = -1;
    res[1] = 0;
    int i = 2;
    int cn = 0;
    while(i < res.length){
        if(str.charAt(i - 1) == str.charAt(cn)){
            res[i++] = ++cn;
        }else if(cn > 0){
            cn = res[cn];
        }else{
            res[i++] = 0;
        }
    }
    return res;   
}

//使用api
public int strStr(String haystack, String needle) {
	return haystack.indexOf(needle);
}
```

## 重复的子字符串

[力扣](https://leetcode-cn.com/problems/repeated-substring-pattern/) 

```java

public boolean repeatedSubstringPattern(String s) {
    int len = s.length();
    int[] next = new int[len+1];
    int i = 2;
    int cn = 0;
    while(i < next.length){
        if(s.charAt(i - 1) == s.charAt(cn)){
            next[i++] = ++cn;
        }else if(cn > 0){
            cn = next[cn];
        }else {
            next[i++] = 0;
        }
    }
    if (next[len] > 0 && len % (len - next[len]) == 0) {
        return true;
    }
    return false;
}
```

# 二叉树

## 二叉树的层序遍历

### 自顶向下

[力扣](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/) 

```java
/*
    题目：
    - 给定一个二叉树根节点root
    - 逐层遍历
    思路：
    - BFS广度优先遍历
    - 用一个队列存放
    - 在当前循环时存放下一层节点到队列中
    - 下一次循环时取出队列中元素并存放到list中
*/
public static List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    Queue<TreeNode> queue = new ArrayDeque<>();
    if (root != null) queue.add(root);
    while (!queue.isEmpty()) {
        int n = queue.size();
        List<Integer> level = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            TreeNode node = queue.poll();
            level.add(node.val);
            if (node.left != null)
                queue.add(node.left);
            if (node.right != null)
                queue.add(node.right);
        }
        res.add(level);
    }
    return res;
}
```

### 自底向上

[力扣](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/) 

```java
/*
	- 将每层节点加入结果时，插入节点头部即可
*/
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    LinkedList<List<Integer>> res = new LinkedList<>();
    Queue<TreeNode> queue = new ArrayDeque<>();
    if (root != null)  queue.add(root);
    while (!queue.isEmpty()) {
        int n = queue.size();
        List<Integer> level = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            TreeNode node = queue.poll();
            level.add(node.val);
            if (node.left != null)
                queue.add(node.left);
            if (node.right != null)
                queue.add(node.right);
        }
        res.addFirst(level);
    }
    return res;
}
```

### Z型遍历

[力扣](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/) 

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    Queue<TreeNode> queue = new ArrayDeque<>();
    int fac = 1;
    if (root != null) queue.add(root);
    while (!queue.isEmpty()) {
        int n = queue.size();
        LinkedList<Integer> level = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            TreeNode node = queue.poll();
            if(fac % 2 == 0){
                level.addFirst(node.val);
            }else{
                level.addLast(node.val);
            }
            if (node.left != null)
                queue.add(node.left);
            if (node.right != null)
                queue.add(node.right);
        }
        fac++;
        res.add(level);
    }
    return res;
}
```

## 翻转二叉树 

[力扣链接](https://leetcode-cn.com/problems/invert-binary-tree/) 

```java
/*
	思路：
	- 递归+后序遍历
*/
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    invertTree(root.left);
    invertTree(root.right);
    swap(root);
    return root;
}
public void swap(TreeNode r){
    TreeNode tmp = r.left;
    r.left = r.right;
    r.right = tmp;
}
```

## 对称二叉树

[力扣链接](https://leetcode-cn.com/problems/symmetric-tree/) 

```java
/*
	题目：
	- 判断树是否是轴对称
	思路：
	- 把树看出左右两棵树
	- 判断左孩子是否等于右孩子
*/
//递归
public boolean isSymmetric(TreeNode root) {
    return check(root, root);
}
public boolean check(TreeNode p, TreeNode q) {
    if (p == null && q == null) return true;
    if (p == null || q == null) return false;
    return p.val == q.val && check(p.left, q.right) && check(p.right, q.left);
}
//迭代
public boolean isSymmetric(TreeNode root) {
    return check(root, root);
}

public boolean check(TreeNode u, TreeNode v) {
    Queue<TreeNode> q = new LinkedList<TreeNode>();
    q.offer(u);
    q.offer(v);
    while (!q.isEmpty()) {
        u = q.poll();
        v = q.poll();
        if (u == null && v == null) {
            continue;
        }
        if ((u == null || v == null) || (u.val != v.val)) {
            return false;
        }

        q.offer(u.left);
        q.offer(v.right);

        q.offer(u.right);
        q.offer(v.left);
    }
    return true;
}
```

## 二叉树的深度

### 最大

[力扣](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) 

```java
//递归
public int maxdepth(treenode root) {
    if (root == null) return 0;
    int leftdepth = maxdepth(root.left);
    int rightdepth = maxdepth(root.right);
    return Math.max(leftdepth, rightdepth) + 1;
}
//层序遍历
public int maxdepth(treenode root) {
    if(root == null) return 0;
    deque<treenode> deque = new linkedlist<>();
    deque.offer(root);
    int depth = 0;
    while (!deque.isempty()) {
        int size = deque.size();
        depth++;
        for (int i = 0; i < size; i++) {
            treenode poll = deque.poll();
            if (poll.left != null) {
                deque.offer(poll.left);
            }
            if (poll.right != null) {
                deque.offer(poll.right);
            }
        }
    }
    return depth;
}
//n叉树
//递归
public int maxDepth(Node root) {
    if (root == null) return 0;
    int depth = 0;
    if (root.children != null){
        for (Node child : root.children){
            depth = Math.max(depth, maxDepth(child));
        }
    }
    return depth + 1; 
} 
//层序
public int maxDepth(Node root) {
    if (root == null)   return 0;
    int depth = 0;
    Queue<Node> que = new LinkedList<>();
    que.offer(root);
    while (!que.isEmpty()){
        depth++;
        int len = que.size();
        while (len > 0){
            Node node = que.poll();
            for (int i = 0; i < node.children.size(); i++)
                if (node.children.get(i) != null) 
                    que.offer(node.children.get(i));
            len--;
        }
    }
    return depth;
}
```

### 最小

[力扣](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/) 

```java
//递归
int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftDepth = minDepth(root.left);
    int rightDepth = minDepth(root.right);
    if (root.left == null) {
        return rightDepth + 1;
    }
    if (root.right == null) {
        return leftDepth + 1;
    }
    // 左右结点都不为null
    return Math.min(leftDepth, rightDepth) + 1;
}
//层序遍历
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    Deque<TreeNode> deque = new LinkedList<>();
    deque.offer(root);
    int depth = 0;
    while (!deque.isEmpty()) {
        int size = deque.size();
        depth++;
        for (int i = 0; i < size; i++) {
            TreeNode poll = deque.poll();
            if (poll.left == null && poll.right == null) {
                return depth;
            }
            if (poll.left != null) {
                deque.offer(poll.left);
            }
            if (poll.right != null) {
                deque.offer(poll.right);
            }
        }
    }
    return depth;
}
```

## 完全二叉树的节点个数

[力扣](https://leetcode-cn.com/problems/count-complete-tree-nodes/) 

```java
public int countNodes(TreeNode root) {
    if(root == null) {
        return 0;
    }
    int leftDepth = getDepth(root.left);
    int rightDepth = getDepth(root.right);
    if (leftDepth == rightDepth) {// 左子树是满二叉树
        return (1 << leftDepth) + countNodes(root.right);
    } else {// 右子树是满二叉树
        return (1 << rightDepth) + countNodes(root.left);
    }
}
private int getDepth(TreeNode root) {
    int depth = 0;
    while (root != null) {
        root = root.left;
        depth++;
    }
    return depth;
}
```

## 平衡二叉树

[力扣](https://leetcode-cn.com/problems/balanced-binary-tree/) 

```java
//求左右高度差
public boolean isBalanced(TreeNode root) {
    if(root == null) return true;
    int leftDepth = getDepth(root.left);
    int rightDepth = getDepth(root.right);
    if(Math.abs(leftDepth - rightDepth) > 1) return false;
    return isBalanced(root.left) && isBalanced(root.right);
}

public int getDepth(TreeNode node){
    if(node == null) return 0;
    int leftdepth = getDepth(node.left);
    int rightdepth = getDepth(node.right);
    return Math.max(leftdepth, rightdepth) + 1;
}
```

## 二叉树的所有路径

[力扣](https://leetcode-cn.com/problems/binary-tree-paths/) 

```java
public List<String> binaryTreePaths(TreeNode root) {
    List<String> paths = new ArrayList<String>();
    constructPaths(root, "", paths);
    return paths;
}

public void constructPaths(TreeNode root, String path, List<String> paths) {
    if (root != null) {

        StringBuffer SB = new StringBuffer(path);
        SB.append(root.val + "");

        // 当前节点是叶子节点
        if (root.left == null && root.right == null) { 
            paths.add(SB.toString()); 
        } else {// 当前节点不是叶子节点，继续递归遍历
            SB.append("->");  
            constructPaths(root.left, SB.toString(), paths);
            constructPaths(root.right, SB.toString(), paths);
        }
    }
} 
```

## 相同的树

[力扣](https://leetcode-cn.com/problems/same-tree/) 

```java
public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) {
        return true;
    } else if (p == null || q == null) {
        return false;
    } else if (p.val != q.val) {
        return false;
    } else {
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
```

## 左叶子之和

[力扣](https://leetcode-cn.com/problems/sum-of-left-leaves/)

```java
//递归
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;
        int leftValue = sumOfLeftLeaves(root.left);    // 左
        int rightValue = sumOfLeftLeaves(root.right);  // 右
                                                       
        int midValue = 0;
        if (root.left != null && root.left.left == null && root.left.right == null) { 
            midValue = root.left.val;
        }
        int sum = midValue + leftValue + rightValue;  // 中
        return sum;
    }
}
//迭代
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;
        Stack<TreeNode> stack = new Stack<> ();
        stack.add(root);
        int result = 0;
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if (node.left != null && node.left.left == null && node.left.right == null) {
                result += node.left.val;
            }
            if (node.right != null) stack.add(node.right);
            if (node.left != null) stack.add(node.left);
        }
        return result;
    }
}
// 层序遍历迭代法
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        int sum = 0;
        if (root == null) return 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            while (size -- > 0) {
                TreeNode node = queue.poll();
                if (node.left != null) { // 左节点不为空
                    queue.offer(node.left);
                    if (node.left.left == null && node.left.right == null){ // 左叶子节点
                        sum += node.left.val;
                    }
                }
                if (node.right != null) queue.offer(node.right);
            }
        }
        return sum;
    }
}
```



## 找树左下角的值

[力扣](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

```java
// 递归法
class Solution {
    private int Deep = -1;
    private int value = 0;
    public int findBottomLeftValue(TreeNode root) {
        value = root.val;
        findLeftValue(root,0);
        return value;
    }

    private void findLeftValue (TreeNode root,int deep) {
        if (root == null) return;
        if (root.left == null && root.right == null) {
            if (deep > Deep) {
                value = root.val;
                Deep = deep;
            }
        }
        if (root.left != null) findLeftValue(root.left,deep + 1);
        if (root.right != null) findLeftValue(root.right,deep + 1);
    }
}
//迭代法
class Solution {

    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int res = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode poll = queue.poll();
                if (i == 0) {
                    res = poll.val;
                }
                if (poll.left != null) {
                    queue.offer(poll.left);
                }
                if (poll.right != null) {
                    queue.offer(poll.right);
                }
            }
        }
        return res;
    }
}
```



## 路径总和

[力扣](https://leetcode-cn.com/problems/path-sum/)

```java
//lc22
public boolean haspathsum(treenode root, int targetsum) {
    if (root == null) return false; // 为空退出
    // 叶子节点判断是否符合
    if (root.left == null && root.right == null) return root.val == targetsum;
    // 求两侧分支的路径和
    return haspathsum(root.left, targetsum - root.val) || haspathsum(root.right, targetsum - root.val);
}
//迭代
public boolean haspathsum(treenode root, int targetsum) {
    if(root==null)return false;
    stack<treenode> stack1 = new stack<>();
    stack<integer> stack2 = new stack<>();
    stack1.push(root);stack2.push(root.val);
    while(!stack1.isempty()){
        int size = stack1.size();
        for(int i=0;i<size;i++){
            treenode node = stack1.pop();int sum=stack2.pop();
            // 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true
            if(node.left==null && node.right==null && sum==targetsum)return true;
            // 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if(node.right!=null){
                stack1.push(node.right);stack2.push(sum+node.right.val);
            }
            // 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if(node.left!=null){
                stack1.push(node.left);stack2.push(sum+node.left.val);
            }
        }
    }
    return false;
}  
```



## 从中序与后序遍历序列构造二叉树

[力扣](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```java
public TreeNode buildTree(int[] inorder, int[] postorder) {
    return buildTree1(inorder, 0, inorder.length, postorder, 0, postorder.length);
}
public TreeNode buildTree1(int[] inorder, int inLeft, int inRight,
                           int[] postorder, int postLeft, int postRight) {
    // 没有元素了
    if (inRight - inLeft < 1) {
        return null;
    }
    // 只有一个元素了
    if (inRight - inLeft == 1) {
        return new TreeNode(inorder[inLeft]);
    }
    // 后序数组postorder里最后一个即为根结点
    int rootVal = postorder[postRight - 1];
    TreeNode root = new TreeNode(rootVal);
    int rootIndex = 0;
    // 根据根结点的值找到该值在中序数组inorder里的位置
    for (int i = inLeft; i < inRight; i++) {
        if (inorder[i] == rootVal) {
            rootIndex = i;
            break;
        }
    }
    // 根据rootIndex划分左右子树
    root.left = buildTree1(inorder, inLeft, rootIndex,
                           postorder, postLeft, postLeft + (rootIndex - inLeft));
    root.right = buildTree1(inorder, rootIndex + 1, inRight,
                            postorder, postLeft + (rootIndex - inLeft), postRight - 1);
    return root;
}
```

## 从前序与中序遍历序列构造二叉树

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    return helper(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
}

public TreeNode helper(int[] preorder, int preLeft, int preRight,
                       int[] inorder, int inLeft, int inRight) {
    // 递归终止条件
    if (inLeft > inRight || preLeft > preRight) return null;

    // val 为前序遍历第一个的值，也即是根节点的值
    // idx 为根据根节点的值来找中序遍历的下标
    int idx = inLeft, val = preorder[preLeft];
    TreeNode root = new TreeNode(val);
    for (int i = inLeft; i <= inRight; i++) {
        if (inorder[i] == val) {
            idx = i;
            break;
        }
    }

    // 根据 idx 来递归找左右子树
    root.left = helper(preorder, preLeft + 1, preLeft + (idx - inLeft),
                       inorder, inLeft, idx - 1);
    root.right = helper(preorder, preLeft + (idx - inLeft) + 1, preRight,
                        inorder, idx + 1, inRight);
    return root;
}
```



## 最大二叉树

[力扣](https://leetcode-cn.com/problems/maximum-binary-tree/)

```java
public TreeNode constructMaximumBinaryTree(int[] nums) {
    return constructMaximumBinaryTree1(nums, 0, nums.length);
}

public TreeNode constructMaximumBinaryTree1(int[] nums, int leftIndex, int rightIndex) {
    if (rightIndex - leftIndex < 1) {// 没有元素了
        return null;
    }
    if (rightIndex - leftIndex == 1) {// 只有一个元素
        return new TreeNode(nums[leftIndex]);
    }
    int maxIndex = leftIndex;// 最大值所在位置
    int maxVal = nums[maxIndex];// 最大值
    for (int i = leftIndex + 1; i < rightIndex; i++) {
        if (nums[i] > maxVal){
            maxVal = nums[i];
            maxIndex = i;
        }
    }
    TreeNode root = new TreeNode(maxVal);
    // 根据maxIndex划分左右子树
    root.left = constructMaximumBinaryTree1(nums, leftIndex, maxIndex);
    root.right = constructMaximumBinaryTree1(nums, maxIndex + 1, rightIndex);
    return root;
}
```



## 合并二叉树

[力扣](https://leetcode-cn.com/problems/merge-two-binary-trees/)

```java
// 递归
public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
    if (root1 == null) return root2;
    if (root2 == null) return root1;

    TreeNode newRoot = new TreeNode(root1.val + root2.val);
    newRoot.left = mergeTrees(root1.left,root2.left);
    newRoot.right = mergeTrees(root1.right,root2.right);
    return newRoot;
}
// 使用栈迭代
public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
    if (root1 == null) {
        return root2;
    }
    if (root2 == null) {
        return root1;
    }
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root2);
    stack.push(root1);
    while (!stack.isEmpty()) {
        TreeNode node1 = stack.pop();
        TreeNode node2 = stack.pop();
        node1.val += node2.val;
        if (node2.right != null && node1.right != null) {
            stack.push(node2.right);
            stack.push(node1.right);
        } else {
            if (node1.right == null) {
                node1.right = node2.right;
            }
        }
        if (node2.left != null && node1.left != null) {
            stack.push(node2.left);
            stack.push(node1.left);
        } else {
            if (node1.left == null) {
                node1.left = node2.left;
            }
        }
    }
    return root1;
}
// 使用队列迭代
public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
    if (root1 == null) return root2;
    if (root2 ==null) return root1;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root1);
    queue.offer(root2);
    while (!queue.isEmpty()) {
        TreeNode node1 = queue.poll();
        TreeNode node2 = queue.poll();
        // 此时两个节点一定不为空，val相加
        node1.val = node1.val + node2.val;
        // 如果两棵树左节点都不为空，加入队列
        if (node1.left != null && node2.left != null) {
            queue.offer(node1.left);
            queue.offer(node2.left);
        }
        // 如果两棵树右节点都不为空，加入队列
        if (node1.right != null && node2.right != null) {
            queue.offer(node1.right);
            queue.offer(node2.right);
        }
        // 若node1的左节点为空，直接赋值
        if (node1.left == null && node2.left != null) {
            node1.left = node2.left;
        }
        // 若node2的左节点为空，直接赋值
        if (node1.right == null && node2.right != null) {
            node1.right = node2.right;
        }
    }
    return root1;
}
```



## 二叉搜索树中的搜索

[力扣](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/) 

```java
public TreeNode searchBST(TreeNode root, int val) {
    while(root != null){
        if(val < root.val){
            root = root.left;
        }else if(val > root.val){
            root = root.right;
        }else{
            return root;
        }
    }
    return null;
}
```

## 验证二叉搜索树

[力扣](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```java
//递归
public boolean isValidBST(TreeNode root) {
    return validBST(Long.MIN_VALUE, Long.MAX_VALUE, root);
}
boolean validBST(long lower, long upper, TreeNode root) {
    if (root == null) return true;
    if (root.val <= lower || root.val >= upper) return false;
    return validBST(lower, root.val, root.left) && validBST(root.val, upper, root.right);
}
//中序遍历
private long prev = Long.MIN_VALUE;
public boolean isValidBST(TreeNode root) {
    if (root == null) {
        return true;
    }
    if (!isValidBST(root.left)) {
        return false;
    }
    if (root.val <= prev) { // 不满足二叉搜索树条件
        return false;
    }
    prev = root.val;
    return isValidBST(root.right);
}
```



## 二叉搜索树的最小绝对差

[力扣](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/) 

```java
//递归
class Solution {
    TreeNode pre;// 记录上一个遍历的结点
    int result = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
       if(root==null)return 0;
       traversal(root);
       return result;
    }
    public void traversal(TreeNode root){
        if(root==null)return;
        //左
        traversal(root.left);
        //中
        if(pre!=null){
            result = Math.min(result,root.val-pre.val);
        }
        pre = root;
        //右
        traversal(root.right);
    }
}
//中序遍历
class Solution {
    TreeNode pre;
    Stack<TreeNode> stack;
    public int getMinimumDifference(TreeNode root) {
        if (root == null) return 0;
        stack = new Stack<>();
        TreeNode cur = root;
        int result = Integer.MAX_VALUE;
        while (cur != null || !stack.isEmpty()) {
            if (cur != null) {
                stack.push(cur); // 将访问的节点放进栈
                cur = cur.left; // 左
            }else {
                cur = stack.pop(); 
                if (pre != null) { // 中
                    result = Math.min(result, cur.val - pre.val);
                }
                pre = cur;
                cur = cur.right; // 右
            }
        }
        return result;
    }
}
```



## 二叉搜索树中的众数

[力扣](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/solution/) 

```java
/*
	题目：
	- 找出出现频率zu
*/
//中序遍历，利用二叉搜索树特性
ArrayList<Integer> resList;
int maxCount;
int count;
TreeNode pre;

public int[] findMode(TreeNode root) {
    resList = new ArrayList<>();
    maxCount = 0;
    count = 0;
    pre = null;
    findMode1(root);
    int[] res = new int[resList.size()];
    for (int i = 0; i < resList.size(); i++) {
        res[i] = resList.get(i);
    }
    return res;
}

public void findMode1(TreeNode root) {
    if (root == null) {
        return;
    }
    findMode1(root.left);

    int rootValue = root.val;
    // 计数
    if (pre == null || rootValue != pre.val) {
        count = 1;
    } else {
        count++;
    }
    // 更新结果以及maxCount
    if (count > maxCount) {
        resList.clear();
        resList.add(rootValue);
        maxCount = count;
    } else if (count == maxCount) {
        resList.add(rootValue);
    }
    pre = root;

    findMode1(root.right);
}
//迭代
public int[] findMode(TreeNode root) {
    TreeNode pre = null;
    Stack<TreeNode> stack = new Stack<>();
    List<Integer> result = new ArrayList<>();
    int maxCount = 0;
    int count = 0;
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            stack.push(cur);
            cur =cur.left;
        }else {
            cur = stack.pop();
            // 计数
            if (pre == null || cur.val != pre.val) {
                count = 1;
            }else {
                count++;
            }
            // 更新结果
            if (count > maxCount) {
                maxCount = count;
                result.clear();
                result.add(cur.val);
            }else if (count == maxCount) {
                result.add(cur.val);
            }
            pre = cur;
            cur = cur.right;
        }
    }
    return result.stream().mapToInt(Integer::intValue).toArray();
}
```



## 二叉树的最近公共祖先

[力扣](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/) 

```java
/*
	可能出现的情况
		情况一
		- p 在 q 下 或 q 在 p 下
		情况二
		- 情况一之外的情况，即需要向上找
	方法一：
	- 遍历这棵树，用一个map保存每一个节点的父节点
	- 用一个set保存从目标节点到root经过的所有节点
	- 另一个目标节点也进行上述操作，记录时如果遇到上述操作中set中有记录的值则返回
	方式二：
	- 如果当前节点下没有目标节点则返回null，有则返回目标节点
	- 对每个节点都进行递归判断
	- 判断该节点的左返回值和右返回值
		- 左右都有目标节点，返回当前节点
		- 哪边有目标节点就返回哪边
*/
//方式一
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    //记录的时每个节点的父节点
    HashMap<TreeNode, TreeNode> parent = new HashMap<>();
    //递归记录
    dg(root,parent);
    //记录目标节点经过的路径
    HashSet<TreeNode> path = new HashSet<>();
    //自底向上记录路径
    while(){...}
    //另一个也自底向上，遇到上面存在的路径则放回即可
}
//方式二
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    //当前节点为空或者是目标节点则返回
    if(root == null || root == p || root == q) return root;
    //递归查找
    TreeNode left = lowestCommonAncestor(root.left, p , q);
    TreeNode right = lowestCommonAncestor(root.right, p , q);
    //当前节点不为空且左右孩子都是目标节点，返回当前节点
    if(left != null && right != null) return root;
    //左右子树不一定有返回值
    return left != null? left: right;
}
```

## 二叉搜索树的最近公共祖先

[力扣](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) 

```java
//递归
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);
    if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);
    return root;
}
//迭代
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    while (true) {
        if (root.val > p.val && root.val > q.val) {
            root = root.left;
        } else if (root.val < p.val && root.val < q.val) {
            root = root.right;
        } else {
            break;
        }
    }
    return root;
}
```



## 二叉搜索树中的插入操作

[力扣](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

```java
public TreeNode insertIntoBST(TreeNode root, int val) {
    if (root == null) return new TreeNode(val);
    TreeNode newRoot = root;
    TreeNode pre = root;
    while (root != null) {
        pre = root;
        if (root.val > val) {
            root = root.left;
        } else if (root.val < val) {
            root = root.right;
        } 
    }
    if (pre.val > val) {
        pre.left = new TreeNode(val);
    } else {
        pre.right = new TreeNode(val);
    }

    return newRoot;
}
```



## 删除二叉搜索树中的节点

[力扣](https://leetcode-cn.com/problems/delete-node-in-a-bst/) 

```java
public TreeNode deleteNode(TreeNode root, int key) {
    root = delete(root,key);
    return root;
}

private TreeNode delete(TreeNode root, int key) {
    if (root == null) return null;

    if (root.val > key) {
        root.left = delete(root.left,key);
    } else if (root.val < key) {
        root.right = delete(root.right,key);
    } else {
        if (root.left == null) return root.right;
        if (root.right == null) return root.left;
        TreeNode tmp = root.right;
        while (tmp.left != null) {
            tmp = tmp.left;
        }
        root.val = tmp.val;
        root.right = delete(root.right,tmp.val);
    }
    return root;
}
```



## 修剪二叉搜索树

[力扣](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

```java
/*
	题目：
	- 给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high
	- 使得所有节点的值在[low, high]中
*/
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if (root == null) {
            return null;
        }
        if (root.val < low) {
            return trimBST(root.right, low, high);
        }
        if (root.val > high) {
            return trimBST(root.left, low, high);
        }
        // root在[low,high]范围内
        root.left = trimBST(root.left, low, high);
        root.right = trimBST(root.right, low, high);
        return root;
    }
}

```

## 将有序数组转换为二叉搜索树

[力扣](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/) 

```java
/*
	题目：
	- 给你一个整数数组 nums ，其中元素已经按 升序 排列
	- 转换为一棵 高度平衡 二叉搜索树
	- 高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
*/
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return sortedArrayToBST(nums, 0, nums.length);
    }
    
    public TreeNode sortedArrayToBST(int[] nums, int left, int right) {
        if (left >= right) {
            return null;
        }
        if (right - left == 1) {
            return new TreeNode(nums[left]);
        }
        int mid = left + (right - left) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = sortedArrayToBST(nums, left, mid);
        root.right = sortedArrayToBST(nums, mid + 1, right);
        return root;
    }
}
```

## 把二叉搜索树转换为累加树

[力扣](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/) 

```java
/*
	题目：
	- 给出二叉 搜索 树的根节点，该树的节点值各不相同
	- 请你将其转换为累加树
	- 每个节点 node 的新值等于原树中大于或等于 node.val 的值之和
*/
class Solution {
    int sum;
    public TreeNode convertBST(TreeNode root) {
        sum = 0;
        convertBST1(root);
        return root;
    }

    // 按右中左顺序遍历，累加即可
    public void convertBST1(TreeNode root) {
        if (root == null) {
            return;
        }
        convertBST1(root.right);
        sum += root.val;
        root.val = sum;
        convertBST1(root.left);
    }
}
```

# 栈与队列

## 用栈实现队列

[力扣链接](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

```java
/*
	题目：
	- 用两个栈实现队列
	思路：
	- 创建两个栈，一个输入栈一个输出栈
	- 元素入队列则把元素加入输入栈
	- 元素出队列则把输入栈的元素弹出并加入输出栈，然后输出栈弹出
*/
Stack<Integer> insert;
Stack<Integer> outside;
public MyQueue(){
    insert = new Stack<>();
    outside = new Stack<>();
}
public void push(int x) {
    insert.push(x);
}
public int pop() {
    //如果输出栈不为空则输出即可
    if(!outside.isEmpty()){
        return outside.pop();
    }
    //输出栈为空则把输入栈的元素弹出并y
    while (!insert.isEmpty()) {
        outside.push(insert.pop());
    }
    return outside.pop();
}
public int peek() {
    if(!outside.isEmpty()){
        return outside.peek();
    }
    while (!insert.isEmpty()) {
        outside.push(insert.pop());
    }
    return outside.peek();
}
public boolean empty() {
    return insert.isEmpty() && outside.isEmpty();
}
```

---

## 用队列实现栈

[力扣链接](https://leetcode-cn.com/problems/implement-stack-using-queues/) 

```java
class MyStack {
    Queue<Integer> queue1;//输入队列
    public MyStack() {
        queue1 = new LinkedList<>();
    }
    
    public void push(int x) {  
        queue1.add(x);
        int n = queue1.size();
        for(int i = 1; i < n; ++i){
            queue1.add(queue1.poll());
        } 
    }
    
    public int pop() {
        return queue1.poll();
    }
    
    public int top() {
        return queue1.peek();
    }
    
    public boolean empty() {
        return queue1.isEmpty();
    }
}
```

## 有效的括号

[力扣](https://leetcode-cn.com/problems/valid-parentheses/) 

```java
/*
	题目：
	- 给定一个只包含括号的字符串，判断是否符合格式
	思路：
	- 遍历字符串，把遇到的左括号的另一边入栈
	- 遇到右括号判断栈尾是否是其左括号，是就出栈
	- 最后判断是否栈空
	思路二：
	- 可以用字符串的replce方法替换{}[]()为空
	- 在判断s
*/
public boolean isValid(String s) {
    Deque<Character> deque = new ArrayDeque<>();
    char ch;
    for (int i = 0; i < s.length(); i++) {
        ch = s.charAt(i);
        //碰到左括号，就把相应的右括号入栈
        if (ch == '(') {
            deque.push(')');
        }else if (ch == '{') {
            deque.push('}');
        }else if (ch == '[') {
            deque.push(']');
        } else if(deque.isEmpty() || deque.pop() != ch) {
            return false;
        }
    }
    //最后判断栈中元素是否匹配
    return deque.isEmpty();
}
```

## 删除字符串中的所有相邻重复项

[力扣](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/) 

```java
/*
	题目：
	- 由小写字母组成的字符串 S
	- 反复删除相邻且相同的字母
*/
public String removeDuplicates(String S) {
    //ArrayDeque会比LinkedList在除了删除元素这一点外会快一点
    //参考：https://stackoverflow.com/questions/6163166/why-is-arraydeque-better-than-linkedlist
    ArrayDeque<Character> deque = new ArrayDeque<>();
    char ch;
    for (int i = 0; i < S.length(); i++) {
        ch = S.charAt(i);
        if (deque.isEmpty() || deque.peek() != ch) {
            deque.push(ch);
        } else {
            deque.pop();
        }
    }
    String str = "";
    //剩余的元素即为不重复的元素
    while (!deque.isEmpty()) {
        str = deque.pop() + str;
    }
    return str;
}
```

## 逆波兰表达式求值

[力扣](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/) 

```java
/*
	题目：
	- 有效的算符包括 +、-、*、/
	- 每个运算对象可以是整数，也可以是另一个逆波兰表达式。
	- 示例 1：
    输入：tokens = ["2","1","+","3","*"]
    输出：9
    解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
*/
public int evalRPN(String[] tokens) {
    Deque<Integer> stack = new LinkedList();
    for (int i = 0; i < tokens.length; ++i) {
        if ("+".equals(tokens[i])) {        // leetcode 内置jdk的问题，不能使用==判断字符串是否相等
            stack.push(stack.pop() + stack.pop());      // 注意 - 和/ 需要特殊处理
        } else if ("-".equals(tokens[i])) {
            stack.push(-stack.pop() + stack.pop());
        } else if ("*".equals(tokens[i])) {
            stack.push(stack.pop() * stack.pop());
        } else if ("/".equals(tokens[i])) {
            int temp1 = stack.pop();
            int temp2 = stack.pop();
            stack.push(temp2 / temp1);
        } else {
            stack.push(Integer.valueOf(tokens[i]));
        }
    }
    return stack.pop();
}
```

## 滑动窗口的最大值

[力扣](https://leetcode-cn.com/problems/sliding-window-maximum/)

```java
/*
	题目：
	- 有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧
	- 只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位
	- 返回 滑动窗口中的最大值 
*/
//解法一
//自定义数组
class MyQueue {
    Deque<Integer> deque = new LinkedList<>();
    //弹出元素时，比较当前要弹出的数值是否等于队列出口的数值，如果相等则弹出
    //同时判断队列当前是否为空
    void poll(int val) {
        if (!deque.isEmpty() && val == deque.peek()) {
            deque.poll();
        }
    }
    //添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出
    //保证队列元素单调递减
    //比如此时队列元素3,1，2将要入队，比1大，所以1弹出，此时队列：3,2
    void add(int val) {
        while (!deque.isEmpty() && val > deque.getLast()) {
            deque.removeLast();
        }
        deque.add(val);
    }
    //队列队顶元素始终为最大值
    int peek() {
        return deque.peek();
    }
}

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums.length == 1) {
            return nums;
        }
        int len = nums.length - k + 1;
        //存放结果元素的数组
        int[] res = new int[len];
        int num = 0;
        //自定义队列
        MyQueue myQueue = new MyQueue();
        //先将前k的元素放入队列
        for (int i = 0; i < k; i++) {
            myQueue.add(nums[i]);
        }
        res[num++] = myQueue.peek();
        for (int i = k; i < nums.length; i++) {
            //滑动窗口移除最前面的元素，移除是判断该元素是否放入队列
            myQueue.poll(nums[i - k]);
            //滑动窗口加入最后面的元素
            myQueue.add(nums[i]);
            //记录对应的最大值
            res[num++] = myQueue.peek();
        }
        return res;
    }
}

//解法二
//利用双端队列手动实现单调队列
/**
 * 用一个单调队列来存储对应的下标，每当窗口滑动的时候，直接取队列的头部指针对应的值放入结果集即可
 * 单调队列类似 （tail -->） 3 --> 2 --> 1 --> 0 (--> head) (右边为头结点，元素存的是下标)
 */
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        ArrayDeque<Integer> deque = new ArrayDeque<>();
        int n = nums.length;
        int[] res = new int[n - k + 1];
        int idx = 0;
        for(int i = 0; i < n; i++) {
            // 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点
            // 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出
            while(!deque.isEmpty() && deque.peek() < i - k + 1){
                deque.poll();
            }
            // 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出
            while(!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }

            deque.offer(i);

            // 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了
            if(i >= k - 1){
                res[idx++] = nums[deque.peek()];
            }
        }
        return res;
    }
}
```

## 前k个高频元素

[力扣](https://leetcode-cn.com/problems/top-k-frequent-elements/) 

```java
/*
	题目：
	- 返回其中出现频率前 k 高的元素
*/
public int[] topKFrequent(int[] nums, int k) {
    int[] result = new int[k];
    HashMap<Integer, Integer> map = new HashMap<>();
    for (int num : nums) {
        map.put(num, map.getOrDefault(num, 0) + 1);
    }

    Set<Map.Entry<Integer, Integer>> entries = map.entrySet();
    // 根据map的value值正序排，相当于一个小顶堆
    PriorityQueue<Map.Entry<Integer, Integer>> queue = new PriorityQueue<>((o1, o2) -> o1.getValue() - o2.getValue());
    for (Map.Entry<Integer, Integer> entry : entries) {
        queue.offer(entry);
        if (queue.size() > k) {
            queue.poll();
        }
    }
    for (int i = k - 1; i >= 0; i--) {
        result[i] = queue.poll().getKey();
    }
    return result;
}
```



# 回溯

## 组合问题

### 组合Ⅰ

[力扣链接](https://leetcode-cn.com/problems/combinations/) 

```java
/*
	题目：
	- 给定n和k，返回[1，n]中所有可能的k个数的组合
	思路：
	- 回溯 + 剪枝
	- 一个集合存放各种情况
*/
//存放总结果
static List<List<Integer>> results = new ArrayList<>();
//存放单次的结果
static LinkedList<Integer> result = new LinkedList<>();

public static List<List<Integer>> combine(int n, int k) {
    dfs(n, k, 1);
    return results;
}
/*
	- n：1-n上组合
	- k：组合几个
	- startIndex：从哪开始找组合
*/
private static void dfs(int n, int k, int startIndex) {
    //终止条件
    //当符合组合条件时返回
    if (result.size() == k){
        results.add(new ArrayList<>(result));
        return;
    }
    //剪枝优化
    //k - result.size() 是还需要的结果个数
    for (int i = startIndex; i <= n - (k - result.size()) + 1; i++){
        result.add(i);
        dfs(n, k, i + 1);
        //把上一轮的组合删除
        result.removeLast();
    }
}
```

---

### 组合总和Ⅰ

[力扣](https://leetcode-cn.com/problems/combination-sum/) 

```java
List<List<Integer>> results = new ArrayList<>();
LinkedList<Integer> result = new LinkedList<>();

public List<List<Integer>> combinationSum(int[] candidates, int target) {
	backTracking(candidates, target, 0);
    return results;
}

public void backTracking(int[] candidates, int target, int startIndex){
    if(target < 0) return;
    if(target == 0) {
        results.add(new ArrayList<>(result));
        return;
    }
    for (int i = startIndex; i < candidates.length; i++) {
        result.add(candidates[i]);
        target -= candidates[i];
        backTracking(candidates,target,i);
        result.removeLast();
        target += candidates[i];
    }
}
```

### 组合总和Ⅱ

[力扣](https://leetcode-cn.com/problems/combination-sum-ii/) 

```java
List<List<Integer>> results = new ArrayList<>();
LinkedList<Integer> result = new LinkedList<>();

public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    Arrays.sort(candidates);
    backTracking(candidates, target, 0);
    return results;
}

public void backTracking(int[] candidates, int target, int startIndex){
    if(target < 0) return;
    if(target == 0) {
        results.add(new ArrayList<>(result));
        return;
    }
    for (int i = startIndex; i < candidates.length; i++) {
        if(i>startIndex && candidates[i] == candidates[i-1]) continue;
        result.add(candidates[i]);
        target -= candidates[i];
        backTracking(candidates,target,i+1);
        result.removeLast();
        target += candidates[i];
    }
}
```

### 组合总和Ⅲ

[力扣链接](https://leetcode-cn.com/problems/combination-sum-iii/) 

```java
/*
	题目：
	- z
	- 找出所有相加之和为 n 的 k 个数的组合
	思路：
	- 主要在回溯时处理相关逻辑
*/
List<List<Integer>> result = new ArrayList<>();
LinkedList<Integer> path = new LinkedList<>();

//n是总和的值
//k是组合的个数
public List<List<Integer>> combinationSum3(int k, int n) {
    backTracking(n, k, 1, 0);
    return result;
}
private void backTracking(int targetSum, int k, int startIndex, int sum) {
    // 减枝
    // sum大于目标值返回，减去加上的i，进行下一轮循环
    if (sum > targetSum) return; 
    // 当前组合个数达到要求
    if (path.size() == k) {
        // 当前的组合满足sum等于targetSum加入结果集中
        if (sum == targetSum) result.add(new ArrayList<>(path));
        // 当前的组合不满足则返回删除，进行下一轮循环
        return;
    }
    // 减枝 9 - (k - path.size()) + 1
    for (int i = startIndex; i <= 9 - (k - path.size()) + 1; i++) {
        path.add(i);
        sum += i;
        backTracking(targetSum, k, i + 1, sum);
        //只要执行了return操下面的代码都会执行
        //回溯
        path.removeLast();
        //回溯
        sum -= i;
    }
}
```

### 电话号码的字母组合

[链接](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/) 

```java
/*
	题目：
	- 给几个数字，返回能够组成的字母组合
	思路：
	- 由于数字越多要拼接的个数越多，嵌套的循环越多
	- 所以要想到回溯算法
*/
//设置全局列表存储最后的结果
List<String> list = new ArrayList<>();

public List<String> letterCombinations(String digits) {
    if (digits == null || digits.length() == 0) {
        return list;
    }
    //初始对应所有的数字，为了直接对应2-9，新增了两个无效的字符串""
    String[] numString = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    //迭代处理
    backTracking(digits, numString, 0);
    return list;
}

//每次迭代获取一个字符串，所以会设计大量的字符串拼接，所以这里选择更为高效的 StringBuild
StringBuilder temp = new StringBuilder();

//比如digits如果为"23",num 为0，则str表示2对应的 abc
public void backTracking(String digits, String[] numString, int num) {
    //遍历全部一次记录一次得到的字符串
    if (num == digits.length()) {
        list.add(temp.toString());
        return;
    }
    //str 表示当前num对应的字符串
    String str = numString[digits.charAt(num) - '0'];
    for (int i = 0; i < str.length(); i++) {
        temp.append(str.charAt(i));
        //c
        backTracking(digits, numString, num + 1);
        //剔除末尾的继续尝试
        temp.deleteCharAt(temp.length() - 1);
    }
}
```

## 分割回文串

[力扣](https://leetcode-cn.com/problems/palindrome-partitioning/)

```java
class Solution {
    List<List<String>> lists = new ArrayList<>();
    Deque<String> deque = new LinkedList<>();

    public List<List<String>> partition(String s) {
        backTracking(s, 0);
        return lists;
    }

    private void backTracking(String s, int startIndex) {
        //如果起始位置大于s的大小，说明找到了一组分割方案
        if (startIndex >= s.length()) {
            lists.add(new ArrayList(deque));
            return;
        }
        for (int i = startIndex; i < s.length(); i++) {
            //如果是回文子串，则记录
            if (isPalindrome(s, startIndex, i)) {
                String str = s.substring(startIndex, i + 1);
                deque.addLast(str);
            } else {
                continue;
            }
            //起始位置后移，保证不重复
            backTracking(s, i + 1);
            deque.removeLast();
        }
    }
    //判断是否是回文串
    private boolean isPalindrome(String s, int startIndex, int end) {
        for (int i = startIndex, j = end; i < j; i++, j--) {
            if (s.charAt(i) != s.charAt(j)) {
                return false;
            }
        }
        return true;
    }
}
```

## 复原IP地址

[力扣](https://leetcode-cn.com/problems/restore-ip-addresses/)

```java
class Solution {
    List<String> result = new ArrayList<>();

    public List<String> restoreIpAddresses(String s) {
        if (s.length() > 12) return result; // 算是剪枝了
        backTrack(s, 0, 0);
        return result;
    }

    // startIndex: 搜索的起始位置， pointNum:添加逗点的数量
    private void backTrack(String s, int startIndex, int pointNum) {
        if (pointNum == 3) {// 逗点数量为3时，分隔结束
            // 判断第四段⼦字符串是否合法，如果合法就放进result中
            if (isValid(s,startIndex,s.length()-1)) {
                result.add(s);
            }
            return;
        }
        for (int i = startIndex; i < s.length(); i++) {
            if (isValid(s, startIndex, i)) {
                s = s.substring(0, i + 1) + "." + s.substring(i + 1);    //在str的后⾯插⼊⼀个逗点
                pointNum++;
                backTrack(s, i + 2, pointNum);// 插⼊逗点之后下⼀个⼦串的起始位置为i+2
                pointNum--;// 回溯
                s = s.substring(0, i + 1) + s.substring(i + 2);// 回溯删掉逗点
            } else {
                break;
            }
        }
    }

    // 判断字符串s在左闭⼜闭区间[start, end]所组成的数字是否合法
    private Boolean isValid(String s, int start, int end) {
        if (start > end) {
            return false;
        }
        if (s.charAt(start) == '0' && start != end) { // 0开头的数字不合法
            return false;
        }
        int num = 0;
        for (int i = start; i <= end; i++) {
            if (s.charAt(i) > '9' || s.charAt(i) < '0') { // 遇到⾮数字字符不合法
                return false;
            }
            num = num * 10 + (s.charAt(i) - '0');
            if (num > 255) { // 如果⼤于255了不合法
                return false;
            }
        }
        return true;
    }
}

//方法二：比上面的方法时间复杂度低，更好地剪枝，优化时间复杂度
class Solution {
    List<String> result = new ArrayList<String>();
	StringBuilder stringBuilder = new StringBuilder();

	public List<String> restoreIpAddresses(String s) {
		restoreIpAddressesHandler(s, 0, 0);
		return result;
	}

	// number表示stringbuilder中ip段的数量
	public void restoreIpAddressesHandler(String s, int start, int number) {
		// 如果start等于s的长度并且ip段的数量是4，则加入结果集，并返回
		if (start == s.length() && number == 4) {
			result.add(stringBuilder.toString());
			return;
		}
		// 如果start等于s的长度但是ip段的数量不为4，或者ip段的数量为4但是start小于s的长度，则直接返回
		if (start == s.length() || number == 4) {
			return;
		}
		// 剪枝：ip段的长度最大是3，并且ip段处于[0,255]
		for (int i = start; i < s.length() && i - start < 3 && Integer.parseInt(s.substring(start, i + 1)) >= 0
				&& Integer.parseInt(s.substring(start, i + 1)) <= 255; i++) {
			// 如果ip段的长度大于1，并且第一位为0的话，continue
			if (i + 1 - start > 1 && s.charAt(start) - '0' == 0) {
				continue;
			}
			stringBuilder.append(s.substring(start, i + 1));
			// 当stringBuilder里的网段数量小于3时，才会加点；如果等于3，说明已经有3段了，最后一段不需要再加点
			if (number < 3) {
				stringBuilder.append(".");
			}
			number++;
			restoreIpAddressesHandler(s, i + 1, number);
			number--;
			// 删除当前stringBuilder最后一个网段，注意考虑点的数量的问题
			stringBuilder.delete(start + number, i + number + 2);
		}
	}
}
```

## 子集

[力扣](https://leetcode-cn.com/problems/subsets/)

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();// 存放符合条件结果的集合
    LinkedList<Integer> path = new LinkedList<>();// 用来存放符合条件结果
    public List<List<Integer>> subsets(int[] nums) {
        if (nums.length == 0){
            result.add(new ArrayList<>());
            return result;
        }
        subsetsHelper(nums, 0);
        return result;
    }

    private void subsetsHelper(int[] nums, int startIndex){
        result.add(new ArrayList<>(path));//「遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合」。
        if (startIndex >= nums.length){ //终止条件可不加
            return;
        }
        for (int i = startIndex; i < nums.length; i++){
            path.add(nums[i]);
            subsetsHelper(nums, i + 1);
            path.removeLast();
        }
    }
}
```

## 子集II

[力扣](https://leetcode-cn.com/problems/subsets-ii/)

```java
class Solution {
   List<List<Integer>> result = new ArrayList<>();// 存放符合条件结果的集合
   LinkedList<Integer> path = new LinkedList<>();// 用来存放符合条件结果
   boolean[] used;
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        if (nums.length == 0){
            result.add(path);
            return result;
        }
        Arrays.sort(nums);
        used = new boolean[nums.length];
        subsetsWithDupHelper(nums, 0);
        return result;
    }
    
    private void subsetsWithDupHelper(int[] nums, int startIndex){
        result.add(new ArrayList<>(path));
        if (startIndex >= nums.length){
            return;
        }
        for (int i = startIndex; i < nums.length; i++){
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]){
                continue;
            }
            path.add(nums[i]);
            used[i] = true;
            subsetsWithDupHelper(nums, i + 1);
            path.removeLast();
            used[i] = false;
        }
    }
}
//不使用used数组
class Solution {

  List<List<Integer>> res = new ArrayList<>();
  LinkedList<Integer> path = new LinkedList<>();
  
  public List<List<Integer>> subsetsWithDup( int[] nums ) {
    Arrays.sort( nums );
    subsetsWithDupHelper( nums, 0 );
    return res;
  }


  private void subsetsWithDupHelper( int[] nums, int start ) {
    res.add( new ArrayList<>( path ) );

    for ( int i = start; i < nums.length; i++ ) {
        // 跳过当前树层使用过的、相同的元素
      if ( i > start && nums[i - 1] == nums[i] ) {
        continue;
      }
      path.add( nums[i] );
      subsetsWithDupHelper( nums, i + 1 );
      path.removeLast();
    }
  }

}
```

## 递增子序列

[力扣](https://leetcode-cn.com/problems/increasing-subsequences/)

```java
class Solution {
    private List<Integer> path = new ArrayList<>();
    private List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        backtracking(nums,0);
        return res;
    }

    private void backtracking (int[] nums, int start) {
        if (path.size() > 1) {
            res.add(new ArrayList<>(path));
        }

        int[] used = new int[201];
        for (int i = start; i < nums.length; i++) {
            if (!path.isEmpty() && nums[i] < path.get(path.size() - 1) ||
                    (used[nums[i] + 100] == 1)) continue;
            used[nums[i] + 100] = 1;
            path.add(nums[i]);
            backtracking(nums, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
//法二：使用map
class Solution {
    //结果集合
    List<List<Integer>> res = new ArrayList<>();
    //路径集合
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        getSubsequences(nums,0);
        return res;
    }
    private void getSubsequences( int[] nums, int start ) {
        if(path.size()>1 ){
            res.add( new ArrayList<>(path) );
            // 注意这里不要加return，要取树上的节点
        }
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int i=start ;i < nums.length ;i++){
            if(!path.isEmpty() && nums[i]< path.getLast()){
                continue;
            }
            // 使用过了当前数字
            if ( map.getOrDefault( nums[i],0 ) >=1 ){
                continue;
            }
            map.put(nums[i],map.getOrDefault( nums[i],0 )+1);
            path.add( nums[i] );
            getSubsequences( nums,i+1 );
            path.removeLast();
        }
    }
}
```

## 全排列

[力扣](https://leetcode-cn.com/problems/permutations/)

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();// 存放符合条件结果的集合
    LinkedList<Integer> path = new LinkedList<>();// 用来存放符合条件结果
    boolean[] used;
    public List<List<Integer>> permute(int[] nums) {
        if (nums.length == 0){
            return result;
        }
        used = new boolean[nums.length];
        permuteHelper(nums);
        return result;
    }

    private void permuteHelper(int[] nums){
        if (path.size() == nums.length){
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++){
            if (used[i]){
                continue;
            }
            used[i] = true;
            path.add(nums[i]);
            permuteHelper(nums);
            path.removeLast();
            used[i] = false;
        }
    }
}
// 解法2：通过判断path中是否存在数字，排除已经选择的数字
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> permute(int[] nums) {
        if (nums.length == 0) return result;
        backtrack(nums, path);
        return result;
    }
    public void backtrack(int[] nums, LinkedList<Integer> path) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
        }
        for (int i =0; i < nums.length; i++) {
            // 如果path中已有，则跳过
            if (path.contains(nums[i])) {
                continue;
            } 
            path.add(nums[i]);
            backtrack(nums, path);
            path.removeLast();
        }
    }
}
```

## 全排列 II

[力扣](https://leetcode-cn.com/problems/permutations-ii/)

```java
class Solution {
    //存放结果
    List<List<Integer>> result = new ArrayList<>();
    //暂存结果
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> permuteUnique(int[] nums) {
        boolean[] used = new boolean[nums.length];
        Arrays.fill(used, false);
        Arrays.sort(nums);
        backTrack(nums, used);
        return result;
    }

    private void backTrack(int[] nums, boolean[] used) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            // used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过
            // used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过
            // 如果同⼀树层nums[i - 1]使⽤过则直接跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            //如果同⼀树⽀nums[i]没使⽤过开始处理
            if (used[i] == false) {
                used[i] = true;//标记同⼀树⽀nums[i]使⽤过，防止同一树枝重复使用
                path.add(nums[i]);
                backTrack(nums, used);
                path.remove(path.size() - 1);//回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复
                used[i] = false;//回溯
            }
        }
    }
}
```

## 重新安排行程

[力扣](https://leetcode-cn.com/problems/reconstruct-itinerary/)

```java
class Solution {
    private Deque<String> res;
    private Map<String, Map<String, Integer>> map;

    private boolean backTracking(int ticketNum){
        if(res.size() == ticketNum + 1){
            return true;
        }
        String last = res.getLast();
        if(map.containsKey(last)){//防止出现null
            for(Map.Entry<String, Integer> target : map.get(last).entrySet()){
                int count = target.getValue();
                if(count > 0){
                    res.add(target.getKey());
                    target.setValue(count - 1);
                    if(backTracking(ticketNum)) return true;
                    res.removeLast();
                    target.setValue(count);
                }
            }
        }
        return false;
    }

    public List<String> findItinerary(List<List<String>> tickets) {
        map = new HashMap<String, Map<String, Integer>>();
        res = new LinkedList<>();
        for(List<String> t : tickets){
            Map<String, Integer> temp;
            if(map.containsKey(t.get(0))){
                temp = map.get(t.get(0));
                temp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);
            }else{
                temp = new TreeMap<>();//升序Map
                temp.put(t.get(1), 1);
            }
            map.put(t.get(0), temp);

        }
        res.add("JFK");
        backTracking(tickets.size());
        return new ArrayList<>(res);
    }
}
```

## N皇后

[力扣](https://leetcode-cn.com/problems/n-queens/)

```java
class Solution {
    List<List<String>> res = new ArrayList<>();

    public List<List<String>> solveNQueens(int n) {
        char[][] chessboard = new char[n][n];
        for (char[] c : chessboard) {
            Arrays.fill(c, '.');
        }
        backTrack(n, 0, chessboard);
        return res;
    }


    public void backTrack(int n, int row, char[][] chessboard) {
        if (row == n) {
            res.add(Array2List(chessboard));
            return;
        }

        for (int col = 0;col < n; ++col) {
            if (isValid (row, col, n, chessboard)) {
                chessboard[row][col] = 'Q';
                backTrack(n, row+1, chessboard);
                chessboard[row][col] = '.';
            }
        }

    }


    public List Array2List(char[][] chessboard) {
        List<String> list = new ArrayList<>();

        for (char[] c : chessboard) {
            list.add(String.copyValueOf(c));
        }
        return list;
    }


    public boolean isValid(int row, int col, int n, char[][] chessboard) {
        // 检查列
        for (int i=0; i<row; ++i) { // 相当于剪枝
            if (chessboard[i][col] == 'Q') {
                return false;
            }
        }

        // 检查45度对角线
        for (int i=row-1, j=col-1; i>=0 && j>=0; i--, j--) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }

        // 检查135度对角线
        for (int i=row-1, j=col+1; i>=0 && j<=n-1; i--, j++) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }
        return true;
    }
}
```

## 解数独

[力扣](https://leetcode-cn.com/problems/sudoku-solver/)

```java
class Solution {
    public void solveSudoku(char[][] board) {
        solveSudokuHelper(board);
    }

    private boolean solveSudokuHelper(char[][] board){
        //「一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，
        // 一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！」
        for (int i = 0; i < 9; i++){ // 遍历行
            for (int j = 0; j < 9; j++){ // 遍历列
                if (board[i][j] != '.'){ // 跳过原始数字
                    continue;
                }
                for (char k = '1'; k <= '9'; k++){ // (i, j) 这个位置放k是否合适
                    if (isValidSudoku(i, j, k, board)){
                        board[i][j] = k;
                        if (solveSudokuHelper(board)){ // 如果找到合适一组立刻返回
                            return true;
                        }
                        board[i][j] = '.';
                    }
                }
                // 9个数都试完了，都不行，那么就返回false
                return false;
                // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！
                // 那么会直接返回， 「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」
            }
        }
        // 遍历完没有返回false，说明找到了合适棋盘位置了
        return true;
    }

    /**
     * 判断棋盘是否合法有如下三个维度:
     *     同行是否重复
     *     同列是否重复
     *     9宫格里是否重复
     */
    private boolean isValidSudoku(int row, int col, char val, char[][] board){
        // 同行是否重复
        for (int i = 0; i < 9; i++){
            if (board[row][i] == val){
                return false;
            }
        }
        // 同列是否重复
        for (int j = 0; j < 9; j++){
            if (board[j][col] == val){
                return false;
            }
        }
        // 9宫格里是否重复
        int startRow = (row / 3) * 3;
        int startCol = (col / 3) * 3;
        for (int i = startRow; i < startRow + 3; i++){
            for (int j = startCol; j < startCol + 3; j++){
                if (board[i][j] == val){
                    return false;
                }
            }
        }
        return true;
    }
}
```



# 贪心

## 分发饼干

[力扣链接](https://leetcode-cn.com/problems/assign-cookies/) 

```java
/*
	题目：
	- 给定一个孩子数组g，g[i]表示第i个孩子的胃口值
	- 给定一个饼干数组s，s[i]表示第i个饼干的尺寸
	- 一个小孩只能拿一块饼干
	- s[i] >= g[i] 孩子满足
	- 求最大满足值
	思路：
	- 尺寸最大的饼干给胃口最大的孩子
*/
public static int findContentChildren(int[] g, int[] s) {
    int ans = 0;
    Arrays.sort(g);
    Arrays.sort(s);
    int i = g.length-1;
    int j = s.length-1;
    while (i >= 0 && j >= 0){
        if(s[j] >= g[i]){
            j--;
            i--;
            ans++;
        }else{
            i--;
        }
    }
    return ans;
}
```

---

## 摆动序列

[力扣](https://leetcode-cn.com/problems/wiggle-subsequence/) 

```java
/*
	题目：
	- 给定一个数组，
	- 如果 arr[0] > arr[1], arr[1] < arr[2], arr[2] > arr[3] .....
	- 则为摆动序列，例如：8, 1, 5, 3, 8, 2, 6
	思路：
	- 贪心
		- 保留上一次的差值
		- 判断与当前差值一正一负即可
*/
public int wiggleMaxLength(int[] nums) {
    int ans = 1;
    if(nums.length < 2){
        return ans;
    }
    int curDiff = 0;
    int preDiff = 0;
    for(int i = 1; i < nums.length; ++i){
        curDiff = nums[i] - nums[i - 1];
        if((preDiff >= 0 && curDiff < 0) || (preDiff <= 0 && curDiff > 0)){
            ans++;
            preDiff = curDiff;
        }
    }
    return ans;
}
```

## 最大子序和

[力扣](https://leetcode-cn.com/problems/maximum-subarray/) 

```java
/*
	题目：
	- 找到一组和最大的连续的子数组，
	思路：
	- count保存的是当前连续数组的最大值
	- sum保存的是全局最大值
	- 有种切块的感觉
	- 各个大块中找最大快，即贪心
*/
public int maxSubArray(int[] nums) {
	if (nums.length == 1) return nums[0];
    int sum = nums[0];
    int count = 0;
    for (int i = 0; i < nums.length; i++){
        count += nums[i];
        // 取区间累计的最大值（相当于不断确定最大子序终止位置）
        sum = Math.max(sum, count); 
        if (count <= 0){
            // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
            count = 0; 
        }
    }
    return sum;
}
```

## 跳跃游戏

### 跳跃游戏Ⅰ

[力扣](https://leetcode-cn.com/problems/jump-game/) 

```java
/*
	题目：
	- 给定一个非负整数数组，你最初位于数组的第一个位置。
	- 数组中的每个元素代表你在该位置可以跳跃的最大长度。
	- 判断你是否能够到达最后一个位置。
*/
public boolean canJump(int[] nums) {
    int rightmost = 0;
    for (int i = 0; i < nums.length; ++i) {
        //i最远可以取到的位置由rightmost决定
        if (i <= rightmost) {
            rightmost = Math.max(rightmost, i + nums[i]);
            if (rightmost >= n - 1) {
                return true;
            }
        }
    }
    return false;
}
```

### 跳跃游戏Ⅱ

[力扣 ](https://leetcode-cn.com/problems/jump-game-ii/)

```java
/*
	题目：
	- 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。
    - 数组中的每个元素代表你在该位置可以跳跃的最大长度。
    - 你的目标是使用最少的跳跃次数到达数组的最后一个位置。
    - 假设你总是可以到达数组的最后一个位置。
    - [2,3,1,1,4] 
    - 7 5 9 4 2 6 8 3 5 4 3 9
    1 2 3 7 1 5 9 3 2 1
*/
//从后往前O(N^2)
public int jump(int[] nums) {
	int position = nums.length - 1;
    int steps = 0;

    while (position > 0) {
        for (int i = 0; i < position; i++) {
            if (i + nums[i] >= position) {
                position = i;
                steps++;
                break;
            }
        }
    }
    return steps;
}
//从前往后O() [2,3,1,1,4]
public int jump(int[] nums) {
    int end = 0;
    int maxPosition = 0; 
    int steps = 0;
    for (int i = 0; i < nums.length - 1; i++) {
        maxPosition = Math.max(maxPosition, i + nums[i]); 
        if (i == end) {
            end = maxPosition;
            steps++;
        }
    }
    return steps;
}
```

## K次取反后最大化的数组和

[力扣](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/)

```java
class Solution {
    public int largestSumAfterKNegations(int[] nums, int K) {
    	// 将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小
	nums = IntStream.of(nums)
		     .boxed()
		     .sorted((o1, o2) -> Math.abs(o2) - Math.abs(o1))
		     .mapToInt(Integer::intValue).toArray();
	int len = nums.length;	    
	for (int i = 0; i < len; i++) {
	    //从前向后遍历，遇到负数将其变为正数，同时K--
	    if (nums[i] < 0 && K > 0) {
	    	nums[i] = -nums[i];
	    	K--;
	    }
	}
	// 如果K还大于0，那么反复转变数值最小的元素，将K用完

	if (K % 2 == 1) nums[len - 1] = -nums[len - 1];
	return Arrays.stream(nums).sum();

    }
}
//二
class Solution {
    public int largestSumAfterKNegations(int[] A, int K) {
        if (A.length == 1) return k % 2 == 0 ? A[0] : -A[0];
        Arrays.sort(A);
        int sum = 0;
        int idx = 0;
        for (int i = 0; i < K; i++) {
            if (i < A.length - 1 && A[idx] < 0) {
                A[idx] = -A[idx];
                if (A[idx] >= Math.abs(A[idx + 1])) idx++;
                continue;
            }
            A[idx] = -A[idx];
        }

        for (int i = 0; i < A.length; i++) {
            sum += A[i];
        }
        return sum;
    }
}
```

## 加油站

[力扣](https://leetcode-cn.com/problems/gas-station/)

```java
// 解法1
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int sum = 0;
        int min = 0;
        for (int i = 0; i < gas.length; i++) {
            sum += (gas[i] - cost[i]);
            min = Math.min(sum, min);
        }

        if (sum < 0) return -1;
        if (min >= 0) return 0;

        for (int i = gas.length - 1; i > 0; i--) {
            min += (gas[i] - cost[i]);
            if (min >= 0) return i;
        }

        return -1;
    }
}
// 解法2
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int curSum = 0;
        int totalSum = 0;
        int index = 0;
        for (int i = 0; i < gas.length; i++) {
            curSum += gas[i] - cost[i];
            totalSum += gas[i] - cost[i];
            if (curSum < 0) {
                index = (i + 1) % gas.length ; 
                curSum = 0;
            }
        }
        if (totalSum < 0) return -1;
        return index;
    }
}
```

## 分发糖果

[力扣](https://leetcode-cn.com/problems/candy/)

```java
/*
	题目：
	- n个小孩站一排，用一个ratings数组表示孩子的评分
	- 每个孩子至少分配到一个糖果
	- 相邻两个孩子评分高的获得更多的糖果
	- 求最少糖果数
	思路：
	- 用一个left数组记录原始数组第一位与其后一位是否呈递增关系
    - 用一个right数组记录原始数组最后一位与其前一位是否呈递增关系
    - 取left和right大的为糖果数
*/
public static int method1(int[] arr){
    int count = 0;
    int[] left = new int[arr.length];
    left[0] = 1;
    int[] right = new int[arr.length];
    right[arr.length-1] = 1;

    for (int i = 1; i < left.length; i++) {
        if(arr[i] > arr[i-1]){
            left[i] = left[i-1] + 1;
        }else{
            left[i] = 1;
        }
    }
    for (int i = right.length - 2; i >= 0; i--) {
        if(arr[i] > arr[i+1]){
            right[i] = right[i+1] + 1;
        }else{
            right[i] = 1;
        }
    }
    for (int i = 0; i < left.length; i++) {
        count += Math.max(left[i],right[i]);
    }
    return count;
}
/*
	拓展：
	- 小孩站成一圈
	思路：
	- 找到原始数组局部最小值，即arr[i-1] >= arr[i] <= arr[i+1]
    - 创建一个辅助数组，长度为arr+2
    - 将局部最小值作为辅助数组的第一个元素和最后一个元素
    - 用线性的方法解决即可，结果-1
*/
```

## 柠檬水找零

[力扣](https://leetcode-cn.com/problems/lemonade-change/)

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int five = 0;
        int ten = 0;

        for (int i = 0; i < bills.length; i++) {
            if (bills[i] == 5) {
                five++;
            } else if (bills[i] == 10) {
                five--;
                ten++;
            } else if (bills[i] == 20) {
                if (ten > 0) {
                    ten--;
                    five--;
                } else {
                    five -= 3;
                }
            }
            if (five < 0 || ten < 0) return false;
        }
        
        return true;
    }
}
```

## 根据身高重建队列

[力扣](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        // 身高从大到小排（身高相同k小的站前面）
        Arrays.sort(people, (a, b) -> {
            if (a[0] == b[0]) return a[1] - b[1];
            return b[0] - a[0];
        });

        LinkedList<int[]> que = new LinkedList<>();
		//相同位置会插入到前面
        for (int[] p : people) {
            que.add(p[1],p);
        }

        return que.toArray(new int[people.length][]);
    }
}
```

## 用最少数量的箭引爆气球

[力扣](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        Arrays.sort(points, (a, b) -> {
            if(a[0] == b[0]) return Integer.compare(a[1], b[1]);
            return Integer.compare(a[0], b[0]);
        });

        int count = points.length;
        for(int i = 1; i < points.length; i++){
            if(points[i][0] <= points[i-1][1]){
                points[i][1] = Math.min(points[i-1][1], points[i][1]);
                count--;
            }
        }
        return count;
    }
}
```

## 无重叠区间

[力扣](https://leetcode-cn.com/problems/non-overlapping-intervals/)

```java
public int eraseOverlapIntervals(int[][] intervals) {
    Arrays.sort(intervals, (a, b) -> {
    	if (a[0] == a[0]) return a[1] - b[1];
        return a[0] - b[0];
    });
    int count = 0;
    int edge = Integer.MIN_VALUE;
    for (int i = 0; i < intervals.length; i++) {
        if (edge <= intervals[i][0]) {
            edge = intervals[i][1];
        } else {
            count++;	
        }
    }
    return count;
}
//按左边排序，不管右边顺序。相交的时候取最小的右边。
public int eraseOverlapIntervals(int[][] intervals) {
    Arrays.sort(intervals,(a,b)->{
        return Integer.compare(a[0],b[0]);
    });
    int remove = 0;
    int pre = intervals[0][1];
    for(int i=1;i<intervals.length;i++){
        if(pre>intervals[i][0]) {
            remove++;
            pre = Math.min(pre,intervals[i][1]);
        }
        else pre = intervals[i][1];
    }
    return remove;
}
```

## 划分字母区间

[力扣](https://leetcode-cn.com/problems/partition-labels/)

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        int[] last = new int[26];
        int len = s.length();
        for(int i = 0; i < len; i++){
            last[s.charAt(i)-'a'] = i;
        }
        List<Integer> res = new ArrayList<>();
        int start = 0, end = 0;
        for(int i = 0; i < len; i++){
            end = Math.max(end, last[s.charAt(i) - 'a']);
            if(i == end){
                res.add(end - start + 1);
                start = end + 1;
            }
        }
        return res;
    }
}
```

## 合并区间

[力扣](https://leetcode-cn.com/problems/merge-intervals/)

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        List<int[]> res = new LinkedList<>();
        Arrays.sort(intervals, (o1, o2) -> Integer.compare(o1[0], o2[0]));
		
        int start = intervals[0][0];
        for (int i = 1; i < intervals.length; i++) {
            //如果[1][0] > [0][1],说明区间不重合，直接添加进结果
            if (intervals[i][0] > intervals[i - 1][1]) {
                res.add(new int[]{start, intervals[i - 1][1]});
                //从后一个位置开始检查
                start = intervals[i][0];
            //如果[1][0] <= [0][1],说明区间重合，让后者的右边界变成两者中右边界大的
            } else {
                intervals[i][1] = Math.max(intervals[i][1], intervals[i - 1][1]);
            }
        }
        //由于上面的循环最后一个区间没法进行比较，所以直接添加
        res.add(new int[]{start, intervals[intervals.length - 1][1]});
        return res.toArray(new int[res.size()][]);
    }
}
```

## 单调递增的数字

[力扣](https://leetcode-cn.com/problems/monotone-increasing-digits/)

```java
class Solution {
    public int monotoneIncreasingDigits(int n) {
        String s = String.valueOf(n);
        char[] chars = s.toCharArray();
        int start = s.length();
        for (int i = s.length() - 2; i >= 0; i--) {
            if (chars[i] > chars[i + 1]) {
                chars[i]--;
                start = i+1;
            }
        }
        //如果上面的if没进则这段循环不会进
        for (int i = start; i < s.length(); i++) {
            chars[i] = '9';
        }
        return Integer.parseInt(String.valueOf(chars));
    }
}
```

## 监控二叉树

[力扣](https://leetcode-cn.com/problems/binary-tree-cameras/)

```java
/*
	- 在树的节点上安装摄像头
	- 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。
	- 计算监控树的所有节点所需的最小摄像头数量。
	- 节点的状态值：
    	- 0 表示无覆盖 
        - 1 表示 有摄像头
        - 2 表示有覆盖 
*/
class Solution {
    int  res=0;
    public int minCameraCover(TreeNode root) {
        // 对根节点的状态做检验,防止根节点是无覆盖状态 .
        if(minCame(root)==0){
            res++;
        }
        return res;
    }
    public int minCame(TreeNode root){
        if(root==null){
            // 空节点默认为 有覆盖状态，避免在叶子节点上放摄像头 
            return 2;
        }
        int left=minCame(root.left);
        int  right=minCame(root.right);
        // 如果左右节点都覆盖了的话, 那么本节点的状态就应该是无覆盖,没有摄像头
        if(left==2&&right==2){
            return 0;
        }else if(left==0||right==0){
            // 左右节点都是无覆盖状态,那 根节点此时应该放一个摄像头
            // 状态值为 1 摄像头数 ++;
            res++;
            return 1;
        }else{
            // 那么本节点就是处于被覆盖状态 
            return 2;
        }
    }
}
```

# 动态规划

## 斐波那契数

```java
//动态规划 f(n) = f(n - 1) * f(n - 2)
public static int fib(int n) {
    if (n < 2) return n;
    //初始时p,q,r 分别对应斐波那契数列前三项
    int p = 0, q = 0, r = 1;
    for (int i = 2; i <= n; ++i) {
        p = q;
        q = r;
        r = p + q;
    }
    return r;
}
//递归实现
public static int fib(int n) {
    if (n < 2) return n;
    return fib(n-1) + fib(n-2);
}
//dp实现
public int fib(int n) {
    if (n <= 1) return n;             
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    for (int index = 2; index <= n; index++){
        dp[index] = dp[index - 1] + dp[index - 2];
    }
    return dp[n];
}
```

---

## 爬楼梯

### 爬楼梯Ⅰ

```java
/*
	题目：
	- 楼梯有N阶
	- 一次可以爬1个或2个台阶
	- 求有多少种爬法
	思路：
	- 爬一层有1种方法，二层有2种方法
	- 类似斐波那契数列
	-
*/
//dp数组
public int climbStairs(int n) {
    if(n == 1) return 1;
    if(n == 2) return 2;
    int[] dp = new int[n + 1];
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
//不使用额外空间
public int climbStairs(int n) {
    int p = 0, q = 0, r = 1;
    for (int i = 1; i <= n; ++i) {
        p = q; 
        q = r; 
        r = p + q;
    }
    return r;
}
/*
	拓展：
	- 一次可以爬n个台阶
*/
/
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        int[] weight = {1,2};
        dp[0] = 1;

        for (int i = 0; i <= n; i++) {
            for (int j = 0; j < weight.length; j++) {
                if (i >= weight[j]) dp[i] += dp[i - weight[j]];
            }
        }

        return dp[n];
    }
}
```

---

### 使用最小花费爬楼梯

[力扣链接](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

```java
/*
	题目：
	-  楼梯有N阶，每层台阶都有代价
	-  一次可以爬1个或2个台阶
	-  求有多少种爬法
	思路：
	- 假设自己站在楼顶，那么代价就是 cost[i-1] + cost[i] 或者 cost[i-2] + cost[i]
	- 提取一下便是最小代价 Math.min(dp[i - 2], dp[i - 1]) + cost[i];
	- dp存的是总代价
*/
//1,100,1,1,1,100,1,1,100,1
public int minCostClimbingStairs(int[] cost) {
	int[] dp = new int[cost.length];
    //这里的dp[0] 相当于第一个台阶的代价
    dp[0] = cost[0];
    dp[1] = cost[1];
    for (int i = 2; i < cost.length; i++) {
        dp[i] = Math.min(dp[i - 2], dp[i - 1]) + cost[i];
    }
    return Math.min(dp[cost.length - 2], dp[cost.length - 1]);
}
```

## 不同路径

### 不同路径Ⅰ

```java
/*
	题目：
	- 给定一个m，n表示一个m行n列的二维数组
	- 求从左上角到右下角的走法
	- 只能向右和向下走
	思路：
	- 当前位置的走法 = 上方的走法 + 左方的走法
*/
public int uniquePaths(int m, int n) {
    int[][] dp = new int[m+1][n+1];
    dp[0][1] = 1;
    dp[1][0] = 0;
    for(int i = 1; i <= m; ++i){
        for(int j = 1; j <= n; ++j){
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }  
    return dp[m][n];   
}
```

### 不同路径Ⅱ

```java
/*
	题目：
	- 给定一个二维数组，数组中0代表能走，1不能走
	- 求从左上角到右下角的走法
	- 只能向右和向下走
	思路：
	- 当前位置不能走则设为0即可
	- 当前位置的走法 = 上方的走法 + 左方的走法
*/
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    //行
    int m = obstacleGrid.length;
    //列
    int n = obstacleGrid[0].length;
    int[][] dp = new int[m+1][n+1];
    dp[0][1] = 1;
    dp[1][0] = 0;
    for(int i = 1; i <= m; ++i){
        for(int j = 1; j <= n; ++j){
            if(obstacleGrid[i-1][j-1] == 1){
                dp[i][j] = 0;
                continue;
            }
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }  
    return dp[m][n];   
}
```

## 整数拆分

[力扣](https://leetcode-cn.com/problems/integer-break/) 

```java
public int integerBreak(int n) {
	int[] dp = new int[n+1];
    dp[2] = 1;
    for(int i = 3; i <= n; i++){
        for(int j = 1; j <= i-j; j++){
            //j*(i-j) 就是比较2个数
            //j*dp[i-j]中dp[i-j]存放的是拆分的数的结果，相当于继续拆分
            dp[i]=Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));
        }
    }
    return dp[n];
}
```

## 不同的二叉搜索树

[力扣](https://leetcode-cn.com/problems/unique-binary-search-trees/) 

```java
public int numTrees(int n) {
	if(n <= 2) return n;
    int[] dp = new int[n+1];
    dp[0] = 1; 
    dp[1] = 1; 
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            //累加每个数都作为根节点的情况
            dp[i] += dp[j - 1] * dp[i - j];
        }
    }
    return dp[n];
}
```

## 分割等和子集

[力扣](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

```java
class Solution {
    public boolean canPartition(int[] nums) {
        if(nums == null || nums.length == 0) return false;
        int n = nums.length;
        int sum = 0;
        for(int num : nums){
            sum += num;
        }
        //总和为奇数，不能平分
        if(sum % 2 != 0) return false;
        int target = sum / 2;
        int[] dp = new int[target + 1];
        for(int i = 0; i < n; i++){
            for(int j = target; j >= nums[i]; j--){
                //物品 i 的重量是 nums[i]，其价值也是 nums[i]
                dp[j] = Math.max(dp[j], dp[j-nums[i]] + nums[i]);
            }
        }
        return dp[target] == target;
    }
}
public class Solution {
    public static void main(String[] args) {
        int num[] = {1,5,11,5};
        canPartition(num);

    }
    public static boolean canPartition(int[] nums) {
        int len = nums.length;
        // 题目已经说非空数组，可以不做非空判断
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        // 特判：如果是奇数，就不符合要求
        if ((sum %2 ) != 0) {
            return false;
        }

        int target = sum / 2; //目标背包容量
        // 创建二维状态数组，行：物品索引，列：容量（包括 0）
        /*
        dp[i][j]表示从数组的 [0, i] 这个子区间内挑选一些正整数
          每个数只能用一次，使得这些数的和恰好等于 j。
        */
        boolean[][] dp = new boolean[len][target + 1];

        // 先填表格第 0 行，第 1 个数只能让容积为它自己的背包恰好装满  （这里的dp[][]数组的含义就是“恰好”，所以就算容积比它大的也不要）
        if (nums[0] <= target) {
            dp[0][nums[0]] = true;
        }
        // 再填表格后面几行
        //外层遍历物品
        for (int i = 1; i < len; i++) {
            //内层遍历背包
            for (int j = 0; j <= target; j++) {
                // 直接从上一行先把结果抄下来，然后再修正
                dp[i][j] = dp[i - 1][j];

                //如果某个物品单独的重量恰好就等于背包的重量，那么也是满足dp数组的定义的
                if (nums[i] == j) {
                    dp[i][j] = true;
                    continue;
                }
                //如果某个物品的重量小于j，那就可以看该物品是否放入背包
                //dp[i - 1][j]表示该物品不放入背包，如果在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true；
                //dp[i - 1][j - nums[i]]表示该物品放入背包。如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i]。
                if (nums[i] < j) {
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];
                }
            }
        }
        for (int i = 0; i < len; i++) {
            for (int j = 0; j <= target; j++) {
                System.out.print(dp[i][j]+" ");
            }
            System.out.println();
        }
        return dp[len - 1][target];
    }
}
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
        }

        if (sum % 2 == 1)
            return false;
        int target = sum / 2;

        //dp[i][j]代表可装物品为0-i，背包容量为j的情况下，背包内容量的最大价值
        int[][] dp = new int[nums.length][target + 1];

        //初始化,dp[0][j]的最大价值nums[0](if j > weight[i])
        //dp[i][0]均为0，不用初始化
        for (int j = nums[0]; j <= target; j++) {
            dp[0][j] = nums[0];
        }

        //遍历物品，遍历背包
        //递推公式:
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j <= target; j++) {
                //背包容量可以容纳nums[i]
                if (j >= nums[i]) {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]);
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        return dp[nums.length - 1][target] == target;
    }
}
```

## 最后一块石头的重量 II

[力扣](https://leetcode-cn.com/problems/last-stone-weight-ii/)

```java
//一维数组版本
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int i : stones) {
            sum += i;
        }
        int target = sum >> 1;
        //初始化dp数组
        int[] dp = new int[target + 1];
        for (int i = 0; i < stones.length; i++) {
            //采用倒序
            for (int j = target; j >= stones[i]; j--) {
                //两种情况，要么放，要么不放
                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum - 2 * dp[target];
    }
}
//二维数组版本（便于理解）
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int s : stones) {
            sum += s;
        }

        int target = sum / 2;
        //初始化，dp[i][j]为可以放0-i物品，背包容量为j的情况下背包中的最大价值
        int[][] dp = new int[stones.length][target + 1];
        //dp[i][0]默认初始化为0
        //dp[0][j]取决于stones[0]
        for (int j = stones[0]; j <= target; j++) {
            dp[0][j] = stones[0];
        }

        for (int i = 1; i < stones.length; i++) {
            for (int j = 1; j <= target; j++) {//注意是等于
                if (j >= stones[i]) {
                    //不放:dp[i - 1][j] 放:dp[i - 1][j - stones[i]] + stones[i]
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]);
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        System.out.println(dp[stones.length - 1][target]);
        return (sum - dp[stones.length - 1][target]) - dp[stones.length - 1][target];
    }
}
```

## 目标和

[力扣](https://leetcode-cn.com/problems/target-sum/)

```java
/*
	题目：
	- 给一个nums和target
	- 元素之间可以加减，算能达到target的组合个数
	思路
	- 
*/
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.length; i++) sum += nums[i];
        if ((target + sum) % 2 != 0) return 0;
        int size = (target + sum) / 2;
        if(size < 0) size = -size;
        int[] dp = new int[size + 1];
        dp[0] = 1;
        for (int i = 0; i < nums.length; i++) {
            for (int j = size; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[size];
    }
}
```

## 一和零

[力扣](https://leetcode-cn.com/problems/ones-and-zeroes/)

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        //dp[i][j]表示i个0和j个1时的最大子集
        int[][] dp = new int[m + 1][n + 1];
        int oneNum, zeroNum;
        for (String str : strs) {
            oneNum = 0;
            zeroNum = 0;
            for (char ch : str.toCharArray()) {
                if (ch == '0') {
                    zeroNum++;
                } else {
                    oneNum++;
                }
            }
            //倒序遍历
            for (int i = m; i >= zeroNum; i--) {
                for (int j = n; j >= oneNum; j--) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
}
```



## 零钱问题

### 零钱兑换Ⅰ

[力扣](https://leetcode-cn.com/problems/coin-change/) 

```java
public int coinChange(int[] coins, int amount) {
    // dp的含义时满足目标值的l
    int[] dp = new int[amount+1];
    Arrays.fill(dp, amount+1);
    dp[0] = 0;
    for(int rest = 1; rest <= amount; rest++){
        for(int index = 0; index < coins.length; index++){
            //零钱小于目标值才能计算
            if(coins[index] <= rest)
                dp[rest] = Math.min(dp[rest], dp[rest - coins[index]] +1);
        }
    }
    return dp[amount] > amount ? -1 : dp[amount];
}
```

###  零钱兑换 II

[力扣](https://leetcode-cn.com/problems/coin-change-2/)

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int i = 0; i < coins.length; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
}
```

## 组合总和 Ⅳ

[力扣](https://leetcode-cn.com/problems/combination-sum-iv/)

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for (int i = 0; i <= target; i++) {
            for (int j = 0; j < nums.length; j++) {
                if (i >= nums[j]) {
                    dp[i] += dp[i - nums[j]];
                }
            }
        }
        return dp[target];
    }
}
```

## 完全平方数

[力扣](https://leetcode-cn.com/problems/perfect-squares/)

```java
class Solution {
    // 版本一，先遍历物品, 再遍历背包
    public int numSquares(int n) {
        int max = Integer.MAX_VALUE;
        int[] dp = new int[n + 1];
        //初始化
        for (int j = 0; j <= n; j++) {
            dp[j] = max;
        }
        //当和为0时，组合的个数为0
        dp[0] = 0;
        // 遍历物品
        for (int i = 1; i * i <= n; i++) {
            // 遍历背包
            for (int j = i * i; j <= n; j++) {
                if (dp[j - i * i] != max) {
                    dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
                }
            }
        }
        return dp[n];
    }
}

class Solution {
    // 版本二， 先遍历背包, 再遍历物品
    public int numSquares(int n) {
        int max = Integer.MAX_VALUE;
        int[] dp = new int[n + 1];
        // 初始化
        for (int j = 0; j <= n; j++) {
            dp[j] = max;
        }
        // 当和为0时，组合的个数为0
        dp[0] = 0;
        // 遍历背包
        for (int j = 1; j <= n; j++) {
            // 遍历物品
            for (int i = 1; i * i <= j; i++) {
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
            }
        }
        return dp[n];
    }
}
```

## 单词拆分

[力扣](https://leetcode-cn.com/problems/word-break/)

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] valid = new boolean[s.length() + 1];
        valid[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (wordDict.contains(s.substring(j,i)) && valid[j]) {
                    valid[i] = true;
                }
            }
        }

        return valid[s.length()];
    }
}

// 回溯法+记忆化
class Solution {
    private Set<String> set;
    private int[] memo;
    public boolean wordBreak(String s, List<String> wordDict) {
        memo = new int[s.length()];
        set = new HashSet<>(wordDict);
        return backtracking(s, 0);
    }

    public boolean backtracking(String s, int startIndex) {
        // System.out.println(startIndex);
        if (startIndex == s.length()) {
            return true;
        }
        if (memo[startIndex] == -1) {
            return false;
        }

        for (int i = startIndex; i < s.length(); i++) {
            String sub = s.substring(startIndex, i + 1);
	    // 拆分出来的单词无法匹配
            if (!set.contains(sub)) {
                continue;                
            }
            boolean res = backtracking(s, i + 1);
            if (res) return true;
        }
        // 这里是关键，找遍了startIndex~s.length()也没能完全匹配，标记从startIndex开始不能找到
        memo[startIndex] = -1;
        return false;
    }
}
```

## 最长递增子序列

[力扣](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 0) return 0;
        int[] dp = new int[nums.length];
		Arrays.fill(dp, 1);
        int max = 1;
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            max = Math.max(max, dp[i]);
        }
        return max;
    }
}
```

## 最长连续递增序列

[力扣](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

```java
//dp
public int findLengthOfLCIS(int[] nums) {
    int[] dp = new int[nums.length];
    int max = 1;
    dp[0] = 1;
    for(int i = 1; i < nums.length; i++){
        if(nums[i] > nums[i-1]) 
            dp[i] = dp[i-1] + 1;
        else  
            dp[i] = 1;
        max = Math.max(max, dp[i]);
    }
    return max;
}
```

## 最长公共子序列

[力扣](https://leetcode-cn.com/problems/longest-common-subsequence/)

```java
public int longestCommonSubsequence(String text1, String text2) {
    // 先对dp数组做初始化操作
    int[][] dp = new int[text1.length() + 1][text2.length() + 1]; 
    for (int i = 1 ; i <= text1.length() ; i++) {
        for (int j = 1; j <= text2.length(); j++) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) { 
                // 开始列出状态转移方程
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[text1.length()][text2.length()];
}
```

## 不相交的线

[力扣](https://leetcode-cn.com/problems/uncrossed-lines/)

```java
class Solution {
  public int maxUncrossedLines(int[] A, int[] B) {
  	int [][] dp = new int[A.length+1][B.length+1];
  	for(int i=1;i<=A.length;i++) {
  		for(int j=1;j<=B.length;j++) {
  			if (A[i-1]==B[j-1]) {
  				dp[i][j]=dp[i-1][j-1]+1;
  			}
  			else {
  				dp[i][j]=Math.max(dp[i-1][j], dp[i][j-1]);
  			}
  		}
  	}
  	return dp[A.length][B.length];
  }
}
```

## 最大子序和

[力扣](https://leetcode-cn.com/problems/maximum-subarray/) 

```java
/*
	题目：
	- 给你一个整数数组 nums ，
	- 找出一个具有最大和的连续子数组，返回其最大和。
	思路：
	- dp数组保存的是当前的最优解
	- ans保存的是全局最优解
*/
public int maxSubArray(int[] nums) {
	int[] dp = new int[nums.length];
    dp[0] = nums[0];
    int ans = dp[0];
    for(int i = 1; i < nums.length; ++i){
        dp[i] = Math.max(dp[i-1] + nums[i], nums[i]);
        ans = Math.max(dp[i], ans);
    }
    return ans;
}
```

## 判断子序列

[力扣](https://leetcode-cn.com/problems/is-subsequence/)

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int length1 = s.length(); 
        int length2 = t.length();
        int[][] dp = new int[length1+1][length2+1];
        for(int i = 1; i <= length1; i++){
            for(int j = 1; j <= length2; j++){
                if(s.charAt(i-1) == t.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] = dp[i][j-1];
                }
            }
        }
        if(dp[length1][length2] == length1){
            return true;
        }else{
            return false;
        }
    }
}
```

## 不同的子序列

[力扣](https://leetcode-cn.com/problems/distinct-subsequences/)

```java
class Solution {
    public int numDistinct(String s, String t) {
        int[][] dp = new int[s.length() + 1][t.length() + 1];
        for (int i = 0; i < s.length() + 1; i++) {
            dp[i][0] = 1;
        }
        
        for (int i = 1; i < s.length() + 1; i++) {
            for (int j = 1; j < t.length() + 1; j++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                }else{
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        
        return dp[s.length()][t.length()];
    }
}
```

## 两个字符串的删除操作

[力扣](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int[][] dp = new int[word1.length() + 1][word2.length() + 1];
        for (int i = 0; i < word1.length() + 1; i++) dp[i][0] = i;
        for (int j = 0; j < word2.length() + 1; j++) dp[0][j] = j;
        
        for (int i = 1; i < word1.length() + 1; i++) {
            for (int j = 1; j < word2.length() + 1; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                }else{
                    dp[i][j] = Math.min(dp[i - 1][j - 1] + 2,
                                        Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));
                }
            }
        }
        
        return dp[word1.length()][word2.length()];
    }
}
```

## 编辑距离

[力扣](https://leetcode-cn.com/problems/edit-distance/)

```java
public int minDistance(String word1, String word2) {
    int m = word1.length();
    int n = word2.length();
    int[][] dp = new int[m + 1][n + 1];
    // 初始化
    for (int i = 1; i <= m; i++) {
        dp[i][0] =  i;
    }
    for (int j = 1; j <= n; j++) {
        dp[0][j] = j;
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            // 因为dp数组有效位从1开始
            // 所以当前遍历到的字符串的位置为i-1 | j-1
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;
            }
        }
    }
    return dp[m][n];
}
```

## 回文子串

[力扣](https://leetcode-cn.com/problems/palindromic-substrings/)

```java
//dp
class Solution {
    public int countSubstrings(String s) {
        int len, ans = 0;
        if (s == null || (len = s.length()) < 1) return 0;
        //dp[i][j]：s字符串下标i到下标j的字串是否是一个回文串，即s[i, j]
        boolean[][] dp = new boolean[len][len];
        for (int j = 0; j < len; j++) {
            for (int i = 0; i <= j; i++) {
                //当两端字母一样时，才可以两端收缩进一步判断
                if (s.charAt(i) == s.charAt(j)) {
                    //i++，j--，即两端收缩之后i,j指针指向同一个字符或者i超过j了,必然是一个回文串
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        //否则通过收缩之后的字串判断
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                } else {//两端字符不一样，不是回文串
                    dp[i][j] = false;
                }
            }
        }
        //遍历每一个字串，统计回文串个数
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len; j++) {
                if (dp[i][j]) ans++;
            }
        }
        return ans;
    }
}
//中心扩散法
class Solution {
    public int countSubstrings(String s) {
        int len, ans = 0;
        if (s == null || (len = s.length()) < 1) return 0;
        //总共有2 * len - 1个中心点
        for (int i = 0; i < 2 * len - 1; i++) {
            //通过遍历每个回文中心，向两边扩散，并判断是否回文字串
            //有两种情况，left == right，right = left + 1，这两种回文中心是不一样的
            int left = i / 2, right = left + i % 2;
            while (left >= 0 && right < len && s.charAt(left) == s.charAt(right)) {
                //如果当前是一个回文串，则记录数量
                ans++;
                left--;
                right++;
            }
        }
        return ans;
    }
}
```

## 最长回文子序列

[力扣](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

```java
public class Solution {
    public int longestPalindromeSubseq(String s) {
        int len = s.length();
        int[][] dp = new int[len + 1][len + 1];
        for (int i = len - 1; i >= 0; i--) { // 从后往前遍历 保证情况不漏
            dp[i][i] = 1; // 初始化
            for (int j = i + 1; j < len; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], Math.max(dp[i][j], dp[i][j - 1]));
                }
            }
        }
        return dp[0][len - 1];
    }
}
```



## 打家劫舍

### 不能抢劫相邻的Ⅰ

[力扣](https://leetcode-cn.com/problems/house-robber/) 

```java
public int rob(int[] nums) {
    if(nums.length < 2) return nums[0];
    if(nums.length == 2) return Math.max(nums[0], nums[1]); 
    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]); 
    for(int i = 2; i < nums.length; i++){
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    return dp[nums.length - 1 ];
}
```

### 围成一圈的Ⅱ

[力扣](https://leetcode-cn.com/problems/house-robber-ii/) 

```java
/*
	- 其实就是把环拆成两个队列
	- 一个是从0到n-1，另一个是从1到n
	-然后返回两个结果最大的。
*/
public int rob(int[] nums) {
    if(nums.length < 2) return nums[0];
    if(nums.length == 2) return Math.max(nums[0], nums[1]); 

    return Math.max(robAction(nums, 0, nums.length - 2), 
                    robAction(nums, 1, nums.length - 1));
}

public int robAction(int[] nums, int start, int end){
    int[] dp = new int[nums.length];
    dp[start] = nums[start];
    dp[start+1] = Math.max(nums[start], nums[start+1]); 

    for(int i = start+ 2; i <= end; i++){
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    return dp[end];
}
```

### 是一颗树Ⅲ

```java
public int rob(TreeNode root) {
    int[] res = robAction(root);
    return Math.max(res[0], res[1]);
}

public int[] robAction(TreeNode root) {
    int res[] = new int[2];
    if (root == null) return res;
    int[] left = robAction(root.left);
    int[] right = robAction(root.right);
    //不算根节点
    res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
    /
    res[1] = root.val + left[0] + right[0];
    return res;
}
```

# 单调栈

## 每日温度

[力扣链接](https://leetcode-cn.com/problems/daily-temperatures/)

```java
/*
	题目：
	- 给定一个温度数组，找比当前温度高的，计算间隔
	思路：
	- 使用单调栈
	- 下标入栈，遇到大于下标对应值的，计算差值
*/
public static int[] dailyTemperatures(int[] temperatures) {
    int length = temperatures.length;
    int[] ans = new int[length];
    Deque<Integer> stack = new ArrayDeque<>();
    for (int i = 0; i < length; i++) {
        int temperature = temperatures[i];
        while (!stack.isEmpty() && temperature > temperatures[stack.peek()]) {
            int prevIndex = stack.pop();
            ans[prevIndex] = i - prevIndex;
        }
        stack.push(i);
    }
    return ans;
}
```

---

## 下一个更大元素 I

[力扣](https://leetcode-cn.com/problems/next-greater-element-i/)

```java
//
public int[] nextGreaterElement(int[] nums1, int[] nums2) {
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    Deque<Integer> stack = new ArrayDeque<Integer>();
    for (int i = nums2.length - 1; i >= 0; --i) {
        int num = nums2[i];
        while (!stack.isEmpty() && num >= stack.peek()) {
            stack.pop();
        }
        map.put(num, stack.isEmpty() ? -1 : stack.peek());
        stack.push(num);
    }
    int[] res = new int[nums1.length];
    for (int i = 0; i < nums1.length; ++i) {
        res[i] = map.get(nums1[i]);
    }
    return res;
}
```

## 下一个更大元素II

[力扣](https://leetcode-cn.com/problems/next-greater-element-ii/)

```java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        //边界判断
        if(nums == null || nums.length <= 1) {
            return new int[]{-1};
        }
        int size = nums.length;
        int[] result = new int[size];//存放结果
        Arrays.fill(result,-1);//默认全部初始化为-1
        Stack<Integer> st= new Stack<>();//栈中存放的是nums中的元素下标
        for(int i = 0; i < 2*size; i++) {
            while(!st.empty() && nums[i % size] > nums[st.peek()]) {
                result[st.peek()] = nums[i % size];//更新result
                st.pop();//弹出栈顶
            }
            st.push(i % size);
        }
        return result;
    }
}
```

## 接雨水

[力扣](https://leetcode-cn.com/problems/trapping-rain-water/)

![image-20230629195124129](../../../../../blog/source/images/image-20230629195124129.png)

```java
/*
	题目：
	- 给定一个数组表示x轴的高度，求feng
*/
//双指针
class Solution {
    public int trap(int[] height) {
        int leftMax = 0;
        int rightMax = 0;
        int left = 0;
        int right = height.length - 1;
        int sum = 0;
        while(left < right){
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            if(height[left] < height[right]){
                sum += leftMax - height[left];
                left++;
            }else{
                sum += rightMax - height[right];
                right--;
            }
        }
        return sum;
    }
}
//dp
class Solution {
    public int trap(int[] height) {
        int length = height.length;
        if (length <= 2) return 0;
        int[] maxLeft = new int[length];
        int[] maxRight = new int[length];
        
        // 记录每个柱子左边柱子最大高度
        maxLeft[0] = height[0];
        for (int i = 1; i< length; i++) maxLeft[i] = Math.max(height[i], maxLeft[i-1]);
        
        // 记录每个柱子右边柱子最大高度
        maxRight[length - 1] = height[length - 1];
        for(int i = length - 2; i >= 0; i--) maxRight[i] = Math.max(height[i], maxRight[i+1]);
        
        // 求和
        int sum = 0;
        for (int i = 0; i < length; i++) {
            int count = Math.min(maxLeft[i], maxRight[i]) - height[i];
            if (count > 0) sum += count;
        }
        return sum;
    }
}
//
public int trap(int[] height) {
    int ans = 0;
    Deque<Integer> stack = new LinkedList<Integer>();
    int n = height.length;
    for (int i = 0; i < n; ++i) {
        while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
            int top = stack.pop();
            if (stack.isEmpty()) {
                break;
            }
            int left = stack.peek();
            int currWidth = i - left - 1;
            int currHeight = Math.min(height[left], height[i]) - height[top];
            ans += currWidth * currHeight;
        }
        stack.push(i);
    }
    return ans;
}
```

## 柱状图中最大的矩形

[力扣](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

```java
//dp
class Solution {
    public int largestRectangleArea(int[] heights) {
        int length = heights.length;
        int[] minLeftIndex = new int [length];
        int[] maxRigthIndex = new int [length];
        // 记录左边第一个小于该柱子的下标
        minLeftIndex[0] = -1 ;
        for (int i = 1; i < length; i++) {
            int t = i - 1;
            // 这里不是用if，而是不断向右寻找的过程
            while (t >= 0 && heights[t] >= heights[i]) t = minLeftIndex[t];
            minLeftIndex[i] = t;
        }
        // 记录每个柱子 右边第一个小于该柱子的下标
        maxRigthIndex[length - 1] = length;
        for (int i = length - 2; i >= 0; i--) {
            int t = i + 1;
            while(t < length && heights[t] >= heights[i]) t = maxRigthIndex[t];
            maxRigthIndex[i] = t;
        }
        // 求和
        int result = 0;
        for (int i = 0; i < length; i++) {
            int sum = heights[i] * (maxRigthIndex[i] - minLeftIndex[i] - 1);
            result = Math.max(sum, result);
        }
        return result;
    }
}
//单调栈
class Solution {
    int largestRectangleArea(int[] heights) {
        Stack<Integer> st = new Stack<Integer>();
        
        // 数组扩容，在头和尾各加入一个元素
        int [] newHeights = new int[heights.length + 2];
        newHeights[0] = 0;
        newHeights[newHeights.length - 1] = 0;
        for (int index = 0; index < heights.length; index++){
            newHeights[index + 1] = heights[index];
        }

        heights = newHeights;
        
        st.push(0);
        int result = 0;
        // 第一个元素已经入栈，从下标1开始
        for (int i = 1; i < heights.length; i++) {
            // 注意heights[i] 是和heights[st.top()] 比较 ，st.top()是下标
            if (heights[i] > heights[st.peek()]) {
                st.push(i);
            } else if (heights[i] == heights[st.peek()]) {
                st.pop(); // 这个可以加，可以不加，效果一样，思路不同
                st.push(i);
            } else {
                while (heights[i] < heights[st.peek()]) { // 注意是while
                    int mid = st.peek();
                    st.pop();
                    int left = st.peek();
                    int right = i;
                    int w = right - left - 1;
                    int h = heights[mid];
                    result = Math.max(result, w * h);
                }
                st.push(i);
            }
        }
        return result;
    }
}
```













