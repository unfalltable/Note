---
title: 区块链基础知识
categories: 区块链
tags: [区块链]
---

## WEB3

- WEB1：只读，静态内容，信息聚合
- WEB2：可读写，可交互，数据存储在中心化服务器
- WEB3：可读写，可拥有


## 平台对比

|                                | 以太坊                                                       | Fabric                                                       | Corda                                                        |
| ------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 节点许可                       | 基于智能合约的规则，将基于文件的每个节点的规则作本地覆盖（override） | 可在节点(node)，通道(channel)和联盟(consortium)级别上配置    | 可信网络映射服务，由每个节点上基于文件的配置进行补充。Corda网络被划分为由单独的证书颁发机构(Certificate Authorities)管理的兼容区域 |
| 身份                           | 公钥-分布式的，可在以太坊的链之间可互操作。通过证明(proofs)与PKI耦合 | 基于具有本地组织身份的PKI。在共识和许可中始终使用组织身份，而不是个人身份 | 基于个人和组织身份的PKI                                      |
| 加密算法                       | secp256k1                                                    | 可插拔 (内置有 secp256r1 和 secp384r1的椭圆算法).            | ed25519 secp256r1 secp256k1 RSA (3072bit) PKCS#1 SPHINCS-256 (experimental 试验阶段) |
| 交易共识                       | 排序(Order)->执行(Execute)/验证(Validate)                    | 执行->排序->验证                                             | 执行/验证->排序/公证(Notarize)                               |
| 应用的责任                     | 将签名的交易发送到网络中的一个节点                           | 直接与所有其他参与者协调以获得背书(endorsment)，管理状态、签名和提交的最优并发锁定(optimistic concurrency locking) | 直接与所有其他参与者协调以获得背书(endorsment)，管理状态、签名和提交的最优并发锁定(optimistic concurrency locking) |
| 共识算法                       | Proof-of-Authority 权威证明 (BFT). Raft (CFT with trusted leader，有可信领导). Istanbul BFT (BFT with deterministic leader rotation 有确定性领导轮换). Tendermint | Kafka/Zab (CFT with trusted leader 有可信领导). Raft (CFT with trusted leader有可信领导) | Raft (CFT with trusted leader有可信领导) BFT                 |
| 智能合约引擎                   | EVM, 进程内沙盒(in-process sandbox)                          | 容器隔离(Docker isolation)                                   | 确定性JVM(Deterministic JVM)                                 |
| 智能合约语言                   | DSL (Solidity, Serpent), 保证确定性                          | 多语言 (Go, Node.js, Java), 可容忍的非确定性                 | Java, Kotlin, 通过推荐的库来实现确定性                       |
| 智能合约生命周期               | 不可篡改，部署容易，链上储存                                 | 需要细致的过程(elaborate process)来部署/更改。链下存储       | 需要节点级管理操作才能部署/更新。链下存储。 正在进行的工作是将共识关键代码与非共识关键代码拆分为不同的存储策略（分别在链上和链下） |
| 智能合约升级                   | 通过编程模式来扩展/迁移代码和数据                            | 通过管理程序和升级交易来替换链下代码                         | 具有基于哈希约束的合同通过节点级管理程序和协调流程进行显式升级和授权。只要根据约束条件和哈希匹配项进行签名，具有签名约束条件的合同就会自动允许执行新版本 |
| 资产数字化/通证化              | 原生带有多标准功能: ERC20/ERC721/ERC777 etc.                 | 无原生通证，定制化方案                                       | 定制化方案，通过Corda通证SDK更容易实现                       |
| 多链                           | 每个链都是唯一的，并且需要单独的节点运行时（最少或3或4个，取决于共识） | 具有共享对等runtime和共享顺序器的本机功能（通道）。用于创建具有隔离状态的侧链的内置治理 | 没有链的概念（共享账本）。交易始终明确地针对特定节点。状态的范围仅限于指定的公证节点，可以将其重新定向到其他公证 |
| 私有交易                       | 公共哈希代表输入                                             | 公共哈希代表输入和私有结束状态                               | 继承的所有交易都是私有的。所有的交易对对验证公正节点         |
| 社区贡献者（至2019年10月）     | Go-Ethereum: 429 Quorum: 383 Besu: 60 Autonity: 360          | Fabric: 185                                                  | Corda: 146                                                   |
| 社区活跃度(Month of Nov. 2019) | Go-Ethereum: 15 authors, 98 PRs Quorum: 9 authors, 13 PRs Besu: 23 authors, 66 PRs Autonity: 6 authors, 6 PRs | Fabric: 31 authors, 220 PRs                                  | Corda: 33 authors, 91 PRs                                    |

## 链种对比

|            | 公有链 | 联盟链                       | 私有链 |
| ---------- | ------ | ---------------------------- | ------ |
| 中心化程度 | 完全   | 部分                         |        |
| 可控性     | 弱     | 强                           |        |
| 数据隐秘性 | 弱     | 强                           |        |
| 交易速度   | 慢     | 快                           |        |
| 场景       |        | 溯源、慈善、<br />金融、保险 |        |

## 区块链

- 使用hash和签名的方式进行加密，使用的是 `sha-256` 
  - collisiom resistance：输入转hash结果不变，但存在哈希碰撞
  - hiding：根据哈希值无法预测输入
  - puzzle friendly：根据输入无法预测哈希值

- 创建账户原理
  - 因为是去中心化的，所以个人即可创建账户，无需审核
  - 创建账户的过程就是创建一个公私钥
    - 公钥就是账号
    - 私钥就是操作账号的权限
    - 对交易进行加密，用私钥加密，公钥解密，也就是一个签名的过程

## 比特币

### 简介

- 区块链中的第一个区块为创世区块
- 是一个基于栈的语言
- 很大程度的保证数据不可篡改
- 转账操作都需要签名（转账发起人的私钥）
- 节点分为全节点和轻节点
  - 全节点
    - 包含block header、 block body、UTXO
      - UTXO存储的是没花出去的交易的输出集合
    - 一直在线，维护完整的区块信息
    - 监听区块链网络上的交易信息，验证每个交易的合法性
    - 决定哪些交易会被打包到区块里
    - 监听其他矿工挖出的区块，验证其合法性
  - 轻节点
    - 包含block header
    - 不是一直在线的
    - 只保存与自己相关的交易，并只能检验与自己相关的交易的合法性
    - 无法检测其他人发布的区块的正确性
    - 可以验证挖矿难度
    - 能检测最长链，但不能检测最长合法链
- 比特币转账需要说明币的来源
- 矿池
  - 一个矿主+很多的矿工
  - 矿主负责全节点的工作，矿工负责计算hash值
  - 分红
    - 按劳分配，通过工作量证明
    - 降低工作难度，矿工提交难度低的区块作为工作证明
  - 私吞情况
    - 不可能的，矿工的任务由矿主分配
    - 收款地址是矿主的，无法私吞
  - 存在恶意竞争的情况
    - 其他矿池安排一些矿工到其他矿池工作
    - 参与其他矿池的分红，但是当这些矿工挖到区块后会选择放弃区块
  - 有危害，当矿池算力达到51%攻击后
    - 可以实现分叉攻击 
    - 可以实现封锁账户

### 结构

- 哈希指针
  - 保存指向区块的哈希值和区块地址
  - 每个区块有一个指针指向前一个区块
    - 这个指针的hash值为前一个区块的数据+前一个区块的hash值
    - 即前一个区块的数据如果发生变化，后一个区块的hash指针就找不到前一个区块了

- 交易结构
  - 记录的是当前区块中所有的交易信息
  
    - 交易id、hash值、版本号、大小、所在区块hash值，确认信息数、交易产生时间、区块产生时间
  
    - 锁定时间
  
      - 一般都是0，即立即生效
  
    - 输入
  
      - txid：之前交易的id
      - vout：这个交易的第几个输出
  
      - ScriptSig：输入脚本
        - asm：
        - hex：
  
    - 输出
  
      - value：交易的金额
      - n：
      - scriptPubKey：输出脚本
        - asm：
        - hex：
        - reqSigs：需要的签名数
        - type：输出的类型
        - address：输出的地址
  
  - 采用的是 `merkle tree` 结构
    - 即一颗二叉树，叶子节点是交易的数据，非叶子节点是hash指针
      - 非叶子节点的hash指针有两个，分别时左右子树
      - 两个指针可以计算得出上一个节点的hash值
    - 提供merkle proof，即交易到merkle tree的根hash值的路径
  
  - 当一个轻节点想知道交易是否包含在对应的区块中的merkle tree时，它需要
    - 计算当前交易的hash值，通知全节点取得另一个hash值
    - 计算得出上一个节点的hash次，循环往复直到根节点
    - 轻节点将计算得出的根节点hash值和当前区块的block header中的根节点hash值进行比较即可
  
  - 可以证明交易存在merkle tree中，proof of membership
    - 如果merkle tree的叶子节点是有序的话，就可以证明某个交易是否在树上
    - 比特币的merkle tree的叶子节点是无序的
  
- 区块结构
  - block header 区块头
    - 比特币协议版本
    - 指向前一个区块区块头的指针
    - 挖矿难度目标阈值target（256byte），被编码成4byte的nBits
    - 挖矿随机数nance（4byte）
    - merkle tree的根hash值 
      - 可以检测出整棵树任何位置的修改
    
  - block body 区块体
    - 存储了具体的交易列表
  

### 协议（POW）

- 解决恶意节点，防止女巫攻击（sybil attack）
  - 女巫攻击：制造大量的账号进行攻击

- 比特币使用算力投票
- 最长链原则
- 挖矿奖励机制
  - 每隔21万个区块奖励减半


### 实现

- 挖矿实现
  - H（block header） <= target
  - 通过修改nonce、merkle tree根哈希值，来使区块头的hash值满足挖矿阈值
  - 平均挖矿时间为10分钟
    - 并不意味这10分钟左右就能出块，公平
    - 出块时间太短会导致分叉过多，导致算力分散，这样提高恶意节点成为最长链的可能
  - 挖矿难度与target是成反比的
    - 最低挖矿难度是1，次数target最大
    - 每隔2016个区块要重新调整目标阈值，大约两星期
    - target = target * 实际产生2016个区块的时间 / (2016*10)
    - target的上调和下调的上限不会超过四倍
  - 当该区块被其他矿工挖出后，会停止当前区块，组装新的候选区块
    - 不可惜，因为每次挖矿的概率都是一样的
- 确认交易机制
  - 交易写入区块后为了防止双花攻击，可以多等6个区块产出后再确认，差不多一小时

    - 存储merkle tree的根hash值，可以检测出整棵树任何位置的修改

### 网络

- 应用层、P2P
- tcp通信
  - 存储merkle tree的根hash值，可以检测出整棵树任何位置的修改

### 交易

- 铸币交易的输出会有目标用户的hash
- 目标用户转账时会校验这个hash是否正确，这样可以避免伪造交易                                                   

## 以太坊

### 简介

- 转账不需要说明币的来源

### 结构

```go
type block struct{
    //前驱哈希块
    PreHash []byte
    //当前哈希块
    CurHash []byte
    //数据
    Data []byte
}
```

区块头

区块体
