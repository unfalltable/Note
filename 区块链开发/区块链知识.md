---
title: 区块链基础
categories: Web3
tags: [web3]
---

## 简介

### WEB3

- WEB1：只读，静态内容，信息聚合
- WEB2：可读写，可交互，数据存储在中心化服务器，受监管
- WEB3：可读写，可拥有，去中心化，不可篡改

### 平台对比

|                                | 以太坊                                                       | Fabric                                                       | Corda                                                        |
| ------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 节点许可                       | 基于智能合约的规则，将基于文件的每个节点的规则作本地覆盖（override） | 可在节点(node)，通道(channel)和联盟(consortium)级别上配置    | 可信网络映射服务，由每个节点上基于文件的配置进行补充。Corda网络被划分为由单独的证书颁发机构(Certificate Authorities)管理的兼容区域 |
| 身份                           | 公钥-分布式的，可在以太坊的链之间可互操作。通过证明(proofs)与PKI耦合 | 基于具有本地组织身份的PKI。在共识和许可中始终使用组织身份，而不是个人身份 | 基于个人和组织身份的PKI                                      |
| 加密算法                       | secp256k1                                                    | 可插拔 (内置有 secp256r1 和 secp384r1的椭圆算法).            | ed25519 secp256r1 secp256k1 RSA (3072bit) PKCS#1 SPHINCS-256 (experimental 试验阶段) |
| 交易共识                       | 排序(Order)->执行(Execute)/验证(Validate)                    | 执行->排序->验证                                             | 执行/验证->排序/公证(Notarize)                               |
| 应用的责任                     | 将签名的交易发送到网络中的一个节点                           | 直接与所有其他参与者协调以获得背书(endorsment)，管理状态、签名和提交的最优并发锁定(optimistic concurrency locking) | 直接与所有其他参与者协调以获得背书(endorsment)，管理状态、签名和提交的最优并发锁定(optimistic concurrency locking) |
| 共识算法                       | Proof-of-Authority 权威证明 (BFT). Raft (CFT with trusted leader，有可信领导). Istanbul BFT (BFT with deterministic leader rotation 有确定性领导轮换). Tendermint | Kafka/Zab (CFT with trusted leader 有可信领导). Raft (CFT with trusted leader有可信领导) | Raft (CFT with trusted leader有可信领导) BFT                 |
| 智能合约引擎                   | EVM, 进程内沙盒(in-process sandbox)                          | 容器隔离(Docker isolation)                                   | 确定性JVM(Deterministic JVM)                                 |
| 智能合约语言                   | DSL (Solidity, Serpent), 保证确定性                          | 多语言 (Go, Node.js, Java), 可容忍的非确定性                 | Java, Kotlin, 通过推荐的库来实现确定性                       |
| 智能合约生命周期               | 不可篡改，部署容易，链上储存                                 | 需要细致的过程(elaborate process)来部署/更改。链下存储       | 需要节点级管理操作才能部署/更新。链下存储。 正在进行的工作是将共识关键代码与非共识关键代码拆分为不同的存储策略（分别在链上和链下） |
| 智能合约升级                   | 通过编程模式来扩展/迁移代码和数据                            | 通过管理程序和升级交易来替换链下代码                         | 具有基于哈希约束的合同通过节点级管理程序和协调流程进行显式升级和授权。只要根据约束条件和哈希匹配项进行签名，具有签名约束条件的合同就会自动允许执行新版本 |
| 资产数字化/通证化              | 原生带有多标准功能: ERC20/ERC721/ERC777 etc.                 | 无原生通证，定制化方案                                       | 定制化方案，通过Corda通证SDK更容易实现                       |
| 多链                           | 每个链都是唯一的，并且需要单独的节点运行时（最少或3或4个，取决于共识） | 具有共享对等runtime和共享顺序器的本机功能（通道）。用于创建具有隔离状态的侧链的内置治理 | 没有链的概念（共享账本）。交易始终明确地针对特定节点。状态的范围仅限于指定的公证节点，可以将其重新定向到其他公证 |
| 私有交易                       | 公共哈希代表输入                                             | 公共哈希代表输入和私有结束状态                               | 继承的所有交易都是私有的。所有的交易对对验证公正节点         |
| 社区贡献者（至2019年10月）     | Go-Ethereum: 429 Quorum: 383 Besu: 60 Autonity: 360          | Fabric: 185                                                  | Corda: 146                                                   |
| 社区活跃度(Month of Nov. 2019) | Go-Ethereum: 15 authors, 98 PRs Quorum: 9 authors, 13 PRs Besu: 23 authors, 66 PRs Autonity: 6 authors, 6 PRs | Fabric: 31 authors, 220 PRs                                  | Corda: 33 authors, 91 PRs                                    |

### 链种对比

|            | 公有链 | 联盟链                       | 私有链 |
| ---------- | ------ | ---------------------------- | ------ |
| 中心化程度 | 完全   | 部分                         |        |
| 可控性     | 弱     | 强                           |        |
| 数据隐秘性 | 弱     | 强                           |        |
| 交易速度   | 慢     | 快                           |        |
| 场景       |        | 溯源、慈善、<br />金融、保险 |        |

### 密码学基础

- 是区块链底层安全机制的保障 
- 对消息签名使用的是非对称加密的签名算法，运用到了 <a href="https://unfalltable.github.io/2023/12/26/Note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E5%AF%86%E7%A0%81%E5%AD%A6/">RSV</a> 
- 柯尔霍夫原则
  - 密钥是保密的，算法和参数是公开的
  - 不需要数学上不可解，现实不可解即可
- 加密
  - 对称加密
    - DES、AES、伪随机数生成
  - 非对称加密
    - 公私钥
    - 安全性来源都是基于数学难题
- 哈希算法
  - collisiom resistance：输入转hash结果不变，但存在哈希碰撞
  - hiding：根据哈希值无法预测输入
  - puzzle friendly：根据输入无法预测哈希值

- 默克尔树
  - 依靠hash来快速确认某个值是否在集合中


## 区块链

### 简介

- 区块链提供了一种让多个参与方在没有一个唯一可信方的情况下达成合作
  
- 区块链上的数据是不可篡改的
  
- 区块链的安全性是通过使用hash和签名的方式进行加密，使用的是 `sha-256` 加密算法
  
- 创建账户原理
  - 因为是去中心化的，所以个人即可创建账户，无需审核
  - 创建账户的过程就是创建一个公私钥
    - 公钥就是账号
    - 私钥就是操作账号的权限
    - 对交易进行加密，用私钥加密，公钥解密，也就是一个签名的过程
- 挖矿
  - 挖矿是无记忆的，即和已经挖矿的时长无关

- 在互不信任的对象之间建立联系

### 结构

#### 哈希指针

- 保存指向区块的哈希值和区块地址
- 每个区块有一个指针指向前一个区块
  - 这个指针的hash值为前一个区块的数据+前一个区块的hash值
  - 即前一个区块的数据如果发生变化，后一个区块的hash指针就找不到前一个区块了

#### 区块结构

- 不同的加密货币中区块的内容不同

### 交易

- 交易现在本地上执行完成，再进行挖矿
  - 因为要先确认块头中的信息
  - 要验证交易的合法性、智能合约的正确执行

## 比特币

### 简介

- 区块链1.0
- 区块链中的第一个区块为创世区块
- 一个节点最大1mb，一个交易250字节，最多有4000个交易，每秒处理大概7个交易
- 是一个基于栈的语言
- 很大程度的保证数据不可篡改
- 使用非对称加密椭圆曲线ECC中的secp256k1曲线
- 转账操作都需要签名（转账发起人的私钥）
  - 转账需要说明币的来源 
- 节点分为全节点和轻节点
  - 全节点
    - 一直在线，维护完整的区块信息
    - 监听区块链网络上的交易信息，验证每个交易的合法性
    - 决定哪些交易会被打包到区块里
    - 监听其他矿工挖出的区块，验证其合法性
  - 轻节点
  	- 包含block header
    - 不是一直在线的
    - 只保存与自己相关的交易，并只能检验与自己相关的交易的合法性
    - 无法检测其他人发布的区块的正确性
    - 可以验证挖矿难度
    - 能检测最长链，但不能检测最长合法链
- 由于网络带宽限制和算力分布限制，比特币限制了单个节点可接收信息和主动链接其他节点的上限。对于接受信息，单个节点最多只能接收117个节点的信息，对于主动链接其他节点，单个节点只能主动联系其他8个节点

### 结构

#### 区块结构

- block header 区块头
  - 存储merkle tree的根hash值，可以检测出整棵树任何位置的修改
  - 比特币协议版本
  - 指向前一个区块区块头的指针（其实是一个哈希）
  - 挖矿难度目标阈值target（256byte），被编码成4byte的nBits
- block body 区块体
  - 存储了具体的交易列表
- UTXO
  - UTXO存储的是没花出去的交易的输出集合

#### 矿池

- 一个矿主+很多的矿工
- 矿主负责全节点的工作，矿工负责计算hash值
- 分红
  - 按劳分配，通过工作量证明
  - 降低工作难度，矿工提交难度低的区块作为工作证明
- 私吞情况
  - 不可能的，矿工的任务由矿主分配
  - 收款地址是矿主的，无法私吞
- 存在恶意竞争的情况
  - 其他矿池安排一些矿工到其他矿池工作
  - 参与其他矿池的分红，但是当这些矿工挖到区块后会选择放弃区块
- 有危害，当矿池算力达到51%攻击后
  - 可以实现分叉攻击 
  - 可以实现封锁账户

### 挖矿

- 出块时间十分钟，同时出块的可能性较小
- 解决恶意节点，防止女巫攻击（sybil attack）
  - 女巫攻击：制造大量的账号进行攻击
- 比特币使用算力投票
- 最长链原则
- 挖矿奖励机制
  - 每隔2016个区块要重新调整目标阈值，大约两星期
  - target = target * 实际产生2016个区块的时间 / (2016*10)
  - target的上调和下调的上限不会超过四倍 
  - 当该区块被其他矿工挖出后，会停止当前区块，组装新的候选区块
  	- 不可惜，因为每次挖矿的概率都是一样的
- 确认交易机制
  - 交易写入区块后为了防止双花攻击，可以多等6个区块产出后再确认，差不多一小时
- 应用层、P2P
- tcp通信
### 交易

#### 结构

- 记录的是当前区块中所有的交易信息
  - 交易id、交易的hash值、版本号、大小、

  - 所在区块hash值，交易确认信息数、交易产生时间、区块产生时间

  - 锁定时间 locktime

    - 一般都是0，即立即生效

  - 输入 vin

    - txid：之前交易的hash值，也就是币的来源
    - vout：这个交易的第几个输出

    - ScriptSig：输入脚本，签名
      - asm：操作
      - hex：

  - 输出 vout

    - value：交易的金额
    - n：这个交易的第几个输出
    - scriptPubKey：输出脚本
      - asm：操作
      - hex：
      - reqSigs：需要的签名数
      - type：输出的类型
      - address：输出的地址 

####  merkle tree 

- 交易的结构时一颗二叉树，叶子节点是交易的数据，非叶子节点是hash指针
  - 非叶子节点的hash指针有两个，分别时左右子树
  - 两个指针可以计算得出上一个节点的hash值
- 提供merkle proof，即交易到merkle tree的根hash值的路径

- 当一个轻节点想知道交易是否包含在对应的区块中的merkle tree时，它需要
  - 计算当前交易的hash值，通知全节点取得另一个hash值
  - 计算得出上一个节点的hash次，循环往复直到根节点
  - 轻节点将计算得出的根节点hash值和当前区块的block header中的根节点hash值进行比较即可
- 可以证明交易存在merkle tree中，proof of membership
  - 如果merkle tree的叶子节点是有序的话，就可以证明某个交易是否在树上
  - 比特币的merkle tree的叶子节点是无序的

- 铸币交易的输出会有目标用户的hash
- 目标用户转账时会校验这个hash是否正确，这样可以避免伪造交易             

#### 交易合法性

- 早期脚本是将当前交易的输入和币的来源的输出拼接在一起验证
- 后出于安全因素改为分别验证
  - 先执行输入脚本，在执行输出脚本
- P2PK
  - 输入
    - 支付人的签名
  - 输出
    - 收款人公钥
    - 检查签名
  - 流程
    - 将输入的签名压入栈
    - 将输出中的公钥压入栈
    - 验证栈中的公钥和签名是否合法
- P2PKH（最常用）
  - 输入
    - 支付人的签名
    - 收款人公钥
  - 输出
    - DUP 复制栈顶元素
    - HASH160 将栈顶元素取hash值
    - 收款人公钥的hash
    - 检查签名
  - 流程
    - 将输入脚本中的支付人的签名压入栈
    - 将输入脚本中的收款人公钥压入栈
    - 复制栈顶元素压入栈（收款人公钥）
    - 将栈顶元素弹出并取hash值压入栈（收款人公钥哈希）
    - 将输出脚本的收款人公钥的hash压入栈
    - 比较栈顶两个元素是否一致（比较两个收款人hash是否一致）
    - 检查签名
- P2SH
  - 输入
    - 支付人的签名
    - 赎回脚本
      - 收款人公钥
      - 检查签名
  - 输出
    - HASH160 将栈顶元素取hash值
    - 赎回脚本
      - 收款人公钥hash
  - 流程
    - 将输入脚本中的支付人的签名压入栈
    - 将输入脚本中的赎回脚本压入栈
    - 将栈顶元素弹出并取hash值压入栈
      - 得到赎回脚本的hash，其实就是收款人公钥的hash
    - 将输出脚本的赎回脚本压入栈
      - 其实就是将收款人公钥的hash压入栈
    - 验证收款人公钥的hash值是否一致
    - 验证输入的签名和输入的赎回脚本中的签名

#### 多重签名

- 需要多个人的签名才可以进行转账
- p2sh实现
  - 封装了公钥
- 有bug，会多压一个冗余数据入栈

### 分叉

- 产生的原因
  - 同时发布区块
  - 分叉攻击
  - 比特币协议发生改变
    - 硬分叉（hard fork）
      - 永久的
      - 向前不兼容
      - 部分节点不更新协议就会出现，而且不会消除
      - 会出现回访攻击和重放攻击
        - 通过chain ID 解决
    - 软分叉（soft fork）
      - 暂时的
      - 向前兼容的是软分叉

### Taproff

- 可以在BTC编写高级脚本

## 以太坊

### 简介

- 区块链2.0
- 出块时间10几秒
- 运行的是去中心化的智能合约，发布后不可修改
- 有账户的性质
  - 能避免双花攻击
  - 余额通过状态树维护，避免篡改余额
  - 有一个随机数记录账户交易的次数
  - 1以太 = 10^18^Wei
  - 账户中可存放合约代码
  - 账户可存储信息
- 发布新的区块时不会包含叔父区块中的交易，会检查叔父区块的合法性（是否符合挖矿难度要求）
- 只有分叉后的第一个叔父节点可以得到奖励、
- 交易需要付燃油费gas
  - 每5个byte需要1个gas 



### 状态树（Modified Merkle Patricia Tree）

- 账户地址到账户状态的映射，键值对
  - key是地址
  - value是账户的状态，通过RLP进行序列化

- 账户地址160位，40个16进制的数
- 类似字典树，但进行了路径压缩
  - 是唯一的
  - 路径压缩对稀疏的数据效果好
  - eth的地址是2^160^ 的随机数，符合稀疏的条件
  - 路径压缩就是把相同前缀的节点进行合并，减小树的高度
- 没有发生变化的节点在区块之间是共享的，有发生变化的需要新建分支
  - 维护没有发生变化的区块，是因为需要保留历史状态
  -  因为交易可能需要回滚，所以需要保留历史状态
  - 因为智能合约的设计复杂，无法推断出账户之前的状态，所以需要保留账户的历史信息
- 大的状态树包含很多小的状态树


### 交易树

- 结构和状态树一样
- 记录的是交易信息

### 收据树

- 结构和状态树一样
- 结合布隆过滤器一起使用
- 每次交易
- 记录的是交易的收据信息，记录了交易的执行结果，收据列表的长度和交易列表的长度一致

### 共识协议POW

-  由于出块时间短，导致出现多个节点同时出块的可能性很高，所以临时性分叉很多
- 大型矿池更有可能成为最长合法连，马太效应
- 以太坊使用基于Ghost协议的共识机制
- 奖励
  - 叔父区块可以获得出块奖励，每次发布新区块最多只有两个叔父区块可以获得奖励
    - 七代以内的叔父 区块才有奖励，逐代递减1/8
  - 发布区块包含叔父区块可以获得1/32奖励，包含多个就有多份奖励

### 挖矿算法

-  使用两个数据集，一个16m的cache，一个1G的dataset
  - 这个大小是会增长的
- 轻节点保存cache即可，矿工节点保存dataset

#### 步骤

-  通过一个种子seed通过某种运算算出一个值，然后依次经过这个运算取值存入cache数组
   -  每隔30000个区块会重新生成seed，即对原来的seed取hash
   -  cache数组的初始大小是16M，每隔30000个区块会增大128k
-  生成一个更大的dataset数组
   -  初始大小是1G，每隔30000个区块会增大8M
   -  读取小数组第 i % cache_size ，对这个数异或 i 再取hash，记为mix
   -  循环256次
      -  通过函数传入mix算出下一个读取的下标
      -  通过函数传入mix和 cache[下标 % cache_size]，得到新的mix
   -  得到 hash(mix) 存入dataset[i]
   -  循环这个操作直到填满dataset
-  根据块头和nonce值，算出一个初始的hash，映射到大数组的某个位置和他的下一个位置
   -  全节点直接访存，轻节点通过下标间接访问    

-  然后这两个位置的数在进行运算得出下两个位置，循环这个操作64次
-  最后算出的值和挖矿难度的目标阈值比对，满足则通过，不 过则改nonce

### 难度调整

- 难度为：max（131072, 父区块难度 + X * Y） + Z
  - 最低难度：131072
  - X：难度调整单位，上一个区块的难度的2048分之1
  - Y：max（n - m，-99）
    - n：有uncle区块为2，否则为1
    - m：（当前区块的时间戳 - 父区块的时间戳） / 9，向下取整
  - Z：2^(区块号-3000000)/100000-2^
    - 难度炸弹，挖矿初期难度炸弹影响较小，越往后难度指数增加

### EVM

#### 简介

- 类似JVM虚拟机，是一个基于栈的虚拟机

#### 日志

![img](https://www.wtf.academy/assets/images/12-3-06b5d454b3752b96000f8a9477fa31de.png)

- 日志用来存储Solidity中的事件
- 结构
  - topics 主题
    - 是一个数组，长度不超过4
    - 第一个元素是事件的签名，此外最多可以包含三个indexed参数
    - indexed标注的参数可以看作是事件的索引键
  - data 数据
    - 普通参数会保存在data中
    - 可以看作是事件的值
    - 不可以被直接检索，可以存储任意大小的数据
    - data存储数据消耗的gas比topics少

#### 汽油费

- 智能合约是一个图灵完备的编程模型
- 如果出现死循环（停机问题）
  - 
- 执行合约中的指令需要收取汽油费，由发起交易的人支付
  - 不同指令消耗的汽油费是不同的
  - 简单的指令汽油费低，复杂或者需要存储数据的指令就很贵

### WETH

- 遵守ERC20标准的以太坊代币
- 和ETH一比一兑换

## 共识机制

### POW

- 工作量证明，即比拼算力
- 通过求得满足难度要求的Hash值即可获得记账权
- 耗费电力，算力集中到了矿池

### POS

- 权益证明，即比拼钱、币龄
- 早期有两边下注的问题
- 验证者
  - 质押抵押金可以参与验证者的选举，抵押金越高越容易成为验证者
  - 抵押金会被锁定一段时间
  - 如果验证者将非法的交易写入区块，则会扣除抵押金

### DPOS

- 委托权益证明 / 代理权益证明
- 角色：投票、见证人、代表
  - 用户投票选出见证人
  - 代表人可以提出提案，用户投票决定是否采纳


### PBFT

- 实用拜占庭容错机制，主要应用于联盟链中
- 三个阶段：预准备阶段、准备阶段和确认阶段，总节点数为N个，“拜占庭节点”有f个
  - 预准备阶段：主节点发布包含待验证记录的预准备消息，接收到预备消息后，每一个节点进入准备阶段
  - 准备阶段：每一个节点验证其正确性，将正确记录保存下来发送给其他节点，直到某一个节点接收到2f个不同节点发送的与预准备阶段接收的记录一致的正确记录，该节点才向其他节点广播确认消息
  - 确认阶段：直到每个诚实节点接收到2f+1个确认消息，协议才终止，各节点对记录达成一致

- 实现区块链的一致性，剔出多余的计算量，避免资源浪费
- 只有一个节点可以提出新区块，因而不会出现“分叉”问题

## Layer2

### rollup

- 在以太坊Layer1上部署合约
- 时刻更新交易数据到Layer2网络中
- 将交易按批次打包交易提交到Layer1的智能合约上
  - 乐观打包
    - Optimistic
      - 引入争议时间延迟机制
      - 使用挑战期保护数据正确性
      - 容易实现
    - Arbitrum
      - 多轮交互式欺诈证明
      - 可组合性
  - 零知识证明打包
    - 安全性依赖密码学，不需要挑战期
    - 计算能力较差

- 然后以太坊主网验证 

## NFT

## DAO

- 将治理规则以智能合约形式编码的去中心化自治组织，与公司制相对
- 组织资源、事项执行、资金分配

## 跨链多链

- 通过两条链的智能合约实现
  - 一般通过资产冻结和生成实现

## 安全问题

- 51%攻击
  - 51%算力攻击
  - 51%货币攻击
- 双花攻击
- 日蚀攻击
  - 孤立节点，恶意节点通过操控该节点可以接收和联系到的节点实现
  - 恶意节点需要有足够的带宽资源才能发动日蚀攻击
  - 如果该恶意节点拥有40%算力，它可以将比特币网络拆分为两个分区，然后在两个分区中都发起51%攻击
  - 如果恶意者只有网络带宽资源而没有算力，依然可以实现双花攻击
- 智能合约漏洞
- 预言机攻击
- 矿池过度套利，过度闪电贷
- 链桥攻击
- 自治管理攻击
- 先跑攻击
  - 利用更高的gas费来使交易更快的执行
